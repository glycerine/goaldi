record lex_tkrec ( text , flags , coord , ) ; 
global lex_kwtab := table ( ) ; 
global lex_optab := table ( ) ; 
global lex_flags := table ( ) ; 
procedure main ( fname ) { ^ f := open ( \ fname ) | % stdin ; 
every ^ t := lex_gentok ( f ) do { writes ( t . text , " " ) ; 
if t === lex_SEMICOL then write ( ) ; 
} ; 
write ( ) ; 
} ; 
procedure lex_error ( problem , input ) { % stderr . write ( "lex error: " , problem , ": " , image ( input ) ) ; 
} ; 
procedure lex_gentok ( f ) { while ^ line := f . read ( ) do { ^ tk := nil ; 
while * line > 0 do { if ^ s := match ( line , lex_ws_rx ) then { line := line [ 1 + * s : 0 ] ; 
} else if s := match ( line , lex_id_rx ) then { line := line [ 1 + * s : 0 ] ; 
if ^ t := \ lex_kwtab [ s ] then { suspend tk := t ; 
} else { lex_IDENT . text := s ; 
suspend tk := lex_IDENT ; 
} ; 
} else if s := match ( line , lex_n1_rx | lex_n2_rx | lex_n3_rx ) then { line := line [ 1 + * s : 0 ] ; 
if ^ n := number ( s ) then { lex_REALLIT . text := image ( n ) ; 
suspend tk := lex_REALLIT ; 
} else { lex_error ( "malformed number" , s ) ; 
} ; 
} else if s := match ( line , lex_op_rx ) then { line := line [ 1 + * s : 0 ] ; 
suspend tk := \ lex_optab [ s ] ~| throw ( "lost operator" , s ) ; 
} else if s := match ( line , lex_s1_rx | lex_r1_rx ) then { line := line [ 1 + * s : 0 ] ; 
lex_STRINGLIT . text := stringval ( s ) ; 
suspend tk := lex_STRINGLIT ; 
} else if s := match ( line , lex_s2_rx ) then { line := "" ; 
lex_error ( "unterminated string" , s ) ; 
} else if s := match ( line , lex_r2_rx ) then { repeat { s ||:= "\n" ; 
if line := f . read ( ) then { if ^ t := match ( line , lex_r3_rx ) then { line := line [ 1 + * t : 0 ] ; 
s ||:= t ; 
lex_STRINGLIT . text := stringval ( s ) ; 
suspend tk := lex_STRINGLIT ; 
break ; 
} else { s ||:= line ; 
} ; 
} else { s := s [ 1 +: 40 ] || "..." ; 
lex_error ( "unterminated raw literal" , s ) ; 
line := "" ; 
break ; 
} ; 
} ; 
} else { s := line [ 1 ] ; 
line := line [ 2 : 0 ] ; 
lex_error ( "unrecognized token" , s ) ; 
} ; 
} ; 
if ( \ lex_flags [ tk ] ) [ - 1 ] == "e" then { suspend lex_SEMICOL ; 
} ; 
} ; 
suspend lex_EOFX ; 
} ; 
procedure match ( line , rx ) { return "" ~== rx . FindString ( line ) ; 
} ; 
procedure stringval ( s ) { if not ( s := quote ( unquote ( s ) ) ) then { lex_error ( "invalid string literal" , s ) ; 
} ; 
return s ; 
} ; 
global lex_ws_rx := regex ( "^([ \\t]+|\\#.*)" ) ; 
global lex_id_rx := regex ( "^[a-zA-Z_][a-zA-Z_0-9]*" ) ; 
global lex_n1_rx := regex ( "^[0-9]+r[0-9a-zA-Z]+" ) ; 
global lex_n2_rx := regex ( "^[0-9][0-9a-fA-F]*[box]" ) ; 
global lex_n3_rx := regex ( "^(\\.[0-9]+|[0-9]+\\.?[0-9]*)([eE][+-]?[0-9]+)?" ) ; 
global lex_s1_rx := regex ( "^\"([^\"\\\\]|\\\\.)*\"" ) ; 
global lex_s2_rx := regex ( "^\"([^\"\\\\]|\\\\.)*$" ) ; 
global lex_r1_rx := regex ( "^`[^`]*`" ) ; 
global lex_r2_rx := regex ( "^`[^`]*$" ) ; 
global lex_r3_rx := regex ( "^[^`]*`" ) ; 
global lex_op_rx ; 
initial { ^ expr := "^(" ; 
every ^ op := ( ! lex_optab ) . key do { every ^ c := ! op do { expr ||:= "\\" || c ; 
} ; 
expr ||:= "|" ; 
} ; 
expr := expr [ 1 : - 1 ] || ")" ; 
lex_op_rx := regexp ( expr ) ; 
} ; 
global lex_IDENT := lex_lit ( "identifier" , "be" ) ; 
global lex_INTLIT := lex_lit ( "integer-literal" , "be" ) ; 
global lex_REALLIT := lex_lit ( "real-literal" , "be" ) ; 
global lex_STRINGLIT := lex_lit ( "string-literal" , "be" ) ; 
global lex_EOFX := lex_lit ( "end-of-file" , "" ) ; 
global lex_BREAK := lex_kwd ( "break" , "be" ) ; 
global lex_BY := lex_kwd ( "by" , "" ) ; 
global lex_CASE := lex_kwd ( "case" , "b" ) ; 
global lex_CATCH := lex_kwd ( "catch" , "b" ) ; 
global lex_CONTINUE := lex_kwd ( "continue" , "be" ) ; 
global lex_CREATE := lex_kwd ( "create" , "b" ) ; 
global lex_DEFAULT := lex_kwd ( "default" , "b" ) ; 
global lex_DO := lex_kwd ( "do" , "" ) ; 
global lex_ELSE := lex_kwd ( "else" , "" ) ; 
global lex_EVERY := lex_kwd ( "every" , "b" ) ; 
global lex_EXTENDS := lex_kwd ( "extends" , "" ) ; 
global lex_FAIL := lex_kwd ( "fail" , "be" ) ; 
global lex_GLOBAL := lex_kwd ( "global" , "b" ) ; 
global lex_IF := lex_kwd ( "if" , "b" ) ; 
global lex_INITIAL := lex_kwd ( "initial" , "b" ) ; 
global lex_LAMBDA := lex_kwd ( "lambda" , "b" ) ; 
global lex_LOCAL := lex_kwd ( "local" , "b" ) ; 
global lex_NOT := lex_kwd ( "not" , "b" ) ; 
global lex_NIL := lex_kwd ( "nil" , "be" ) ; 
global lex_OF := lex_kwd ( "of" , "" ) ; 
global lex_PACKAGE := lex_kwd ( "package" , "b" ) ; 
global lex_PROCEDURE := lex_kwd ( "procedure" , "b" ) ; 
global lex_RECORD := lex_kwd ( "record" , "b" ) ; 
global lex_REPEAT := lex_kwd ( "repeat" , "b" ) ; 
global lex_RETURN := lex_kwd ( "return" , "be" ) ; 
global lex_SELECT := lex_kwd ( "select" , "b" ) ; 
global lex_STATIC := lex_kwd ( "static" , "b" ) ; 
global lex_SUSPEND := lex_kwd ( "suspend" , "be" ) ; 
global lex_THEN := lex_kwd ( "then" , "" ) ; 
global lex_TO := lex_kwd ( "to" , "" ) ; 
global lex_UNTIL := lex_kwd ( "until" , "b" ) ; 
global lex_WHILE := lex_kwd ( "while" , "b" ) ; 
global lex_WITH := lex_kwd ( "with" , "b" ) ; 
global lex_YIELD := lex_kwd ( "yield" , "be" ) ; 
global lex_ASSIGN := lex_opr ( ":=" , "" ) ; 
global lex_AT := lex_opr ( "@" , "b" ) ; 
global lex_ATCOLON := lex_opr ( "@:" , "" ) ; 
global lex_AUGAT := lex_opr ( "@:=" , "" ) ; 
global lex_AUGAND := lex_opr ( "&:=" , "" ) ; 
global lex_AUGNMEQ := lex_opr ( "=:=" , "" ) ; 
global lex_AUGEQUIV := lex_opr ( "===:=" , "" ) ; 
global lex_AUGNMGE := lex_opr ( ">=:=" , "" ) ; 
global lex_AUGNMGT := lex_opr ( ">:=" , "" ) ; 
global lex_AUGNMLE := lex_opr ( "<=:=" , "" ) ; 
global lex_AUGNMLT := lex_opr ( "<:=" , "" ) ; 
global lex_AUGNMNE := lex_opr ( "~=:=" , "" ) ; 
global lex_AUGNEQUIV := lex_opr ( "~===:=" , "" ) ; 
global lex_AUGSEQ := lex_opr ( "==:=" , "" ) ; 
global lex_AUGSGE := lex_opr ( ">>=:=" , "" ) ; 
global lex_AUGSGT := lex_opr ( ">>:=" , "" ) ; 
global lex_AUGSLE := lex_opr ( "<<=:=" , "" ) ; 
global lex_AUGSLT := lex_opr ( "<<:=" , "" ) ; 
global lex_AUGSNE := lex_opr ( "~==:=" , "" ) ; 
global lex_BACKSLASH := lex_opr ( "\\" , "b" ) ; 
global lex_BANG := lex_opr ( "!" , "b" ) ; 
global lex_BAR := lex_opr ( "|" , "b" ) ; 
global lex_TILDEBAR := lex_opr ( "~|" , "" ) ; 
global lex_CARET := lex_opr ( "^" , "b" ) ; 
global lex_AUGCARET := lex_opr ( "^:=" , "b" ) ; 
global lex_COLON := lex_opr ( ":" , "" ) ; 
global lex_COLONCOLON := lex_opr ( "::" , "" ) ; 
global lex_COMMA := lex_opr ( "," , "" ) ; 
global lex_CONCAT := lex_opr ( "||" , "b" ) ; 
global lex_AUGCONCAT := lex_opr ( "||:=" , "" ) ; 
global lex_AND := lex_opr ( "&" , "" ) ; 
global lex_ANDAND := lex_opr ( "&&" , "b" ) ; 
global lex_DOT := lex_opr ( "." , "b" ) ; 
global lex_DIFF := lex_opr ( "--" , "b" ) ; 
global lex_AUGDIFF := lex_opr ( "--:=" , "" ) ; 
global lex_EQUIV := lex_opr ( "===" , "b" ) ; 
global lex_INTER := lex_opr ( "**" , "b" ) ; 
global lex_AUGINTER := lex_opr ( "**:=" , "" ) ; 
global lex_LBRACE := lex_opr ( "{" , "b" ) ; 
global lex_LBRACK := lex_opr ( "[" , "b" ) ; 
global lex_LCOMP := lex_opr ( "[:" , "b" ) ; 
global lex_LCONCAT := lex_opr ( "|||" , "b" ) ; 
global lex_AUGLCONCAT := lex_opr ( "|||:=" , "" ) ; 
global lex_SEQ := lex_opr ( "==" , "b" ) ; 
global lex_SGE := lex_opr ( ">>=" , "" ) ; 
global lex_SGT := lex_opr ( ">>" , "" ) ; 
global lex_SLE := lex_opr ( "<<=" , "" ) ; 
global lex_SLT := lex_opr ( "<<" , "" ) ; 
global lex_SNE := lex_opr ( "~==" , "b" ) ; 
global lex_LPAREN := lex_opr ( "(" , "b" ) ; 
global lex_MCOLON := lex_opr ( "-:" , "" ) ; 
global lex_MINUS := lex_opr ( "-" , "b" ) ; 
global lex_AUGMINUS := lex_opr ( "-:=" , "" ) ; 
global lex_MOD := lex_opr ( "%" , "b" ) ; 
global lex_AUGMOD := lex_opr ( "%:=" , "" ) ; 
global lex_NEQUIV := lex_opr ( "~===" , "b" ) ; 
global lex_NMEQ := lex_opr ( "=" , "b" ) ; 
global lex_NMGE := lex_opr ( ">=" , "" ) ; 
global lex_NMGT := lex_opr ( ">" , "" ) ; 
global lex_NMLE := lex_opr ( "<=" , "" ) ; 
global lex_NMLT := lex_opr ( "<" , "" ) ; 
global lex_NMNE := lex_opr ( "~=" , "b" ) ; 
global lex_PCOLON := lex_opr ( "+:" , "" ) ; 
global lex_PLUS := lex_opr ( "+" , "b" ) ; 
global lex_AUGPLUS := lex_opr ( "+:=" , "" ) ; 
global lex_QMARK := lex_opr ( "?" , "b" ) ; 
global lex_REVASSIGN := lex_opr ( "<-" , "" ) ; 
global lex_REVSWAP := lex_opr ( "<->" , "" ) ; 
global lex_RBRACE := lex_opr ( "}" , "e" ) ; 
global lex_RBRACK := lex_opr ( "]" , "e" ) ; 
global lex_RCOMP := lex_opr ( ":]" , "e" ) ; 
global lex_RPAREN := lex_opr ( ")" , "e" ) ; 
global lex_SEMICOL := lex_opr ( ";" , "" ) ; 
global lex_AUGQMARK := lex_opr ( "?:=" , "" ) ; 
global lex_SLASH := lex_opr ( "/" , "b" ) ; 
global lex_AUGSLASH := lex_opr ( "/:=" , "" ) ; 
global lex_SLASHSLASH := lex_opr ( "//" , "b" ) ; 
global lex_AUGSLASHSLASH := lex_opr ( "//:=" , "" ) ; 
global lex_STAR := lex_opr ( "*" , "b" ) ; 
global lex_AUGSTAR := lex_opr ( "*:=" , "" ) ; 
global lex_SWAP := lex_opr ( ":=:" , "" ) ; 
global lex_TILDE := lex_opr ( "~" , "b" ) ; 
global lex_UNION := lex_opr ( "++" , "b" ) ; 
global lex_AUGUNION := lex_opr ( "++:=" , "" ) ; 
procedure lex_lit ( text , flags ) { return lex_token ( text , flags ) ; 
} ; 
procedure lex_kwd ( text , flags ) { return lex_kwtab [ text ] := lex_token ( text , flags ) ; 
} ; 
procedure lex_opr ( text , flags ) { return lex_optab [ text ] := lex_token ( text , flags ) ; 
} ; 
procedure lex_token ( text , flags ) { ^ r := lex_tkrec ( text , flags ) ; 
lex_flags [ r ] := flags ; 
return r ; 
} ; 
end-of-file 
