#  gen_bc.icn -- filter to create class files from intermediate representation

global bc_undeclared_table

global bc_lvalset
global bc_function_name

global bc_stackptr

global bc_nodebuginfo

global bc_java_classname

global bc_indirect_targets
global bc_directory

global bc_current_classptr
global bc_current_classname
global bc_vProc_classname
global bc_vClosure_classname
global bc_switch_label

global bc_tmplabel_table
global bc_tmplabel_offset

global bc_create_exists
global bc_save_restore_flag
global bc_declare_set
global bc_undeclared_set
global bc_debug
global bc_labels
global bc_ir2bc_labels
global bc_emit_table
global bc_invoke_set
global bc_invoke_all
global bc_link_set
global bc_global_set
global bc_record_table
global bc_proc_table
global bc_op_table
global bc_tmp_table
global bc_tmp_offset
global bc_var_set
global bc_var_field
global bc_var_table
global bc_var_offset
global bc_key_table
global bc_args_set

global bc_cset_table
global bc_real_table
global bc_string_table
global bc_integer_table

global bc_locals_set
global bc_params_set
global bc_statics_set

procedure bc_transfer_to(s, p)
    case type(p) of {
    default: runerr(500, p)
    "ir_Label" : {
        put(s, j_goto_w(\bc_ir2bc_labels[p]) ) | runerr(500, p)
    }
    "ir_TmpLabel": {
        bc_gen_rval(s, p)
        put(s, j_goto_w(bc_switch_label) )
    }
    }
    return s
end

procedure bc_conditional_transfer_to(s, p, cond, notcond)
    local tmp

    tmp := j_label()
    put(s, notcond(tmp))

    case type(p) of {
    default: runerr(500, p)
    "ir_Label" : {
        put(s, j_goto_w(\bc_ir2bc_labels[p]) ) | runerr(500, p)
    }
    "ir_TmpLabel": {
        bc_gen_rval(s, p)
        put(s, j_goto_w(bc_switch_label) )
    }
    }

    put(s, tmp)
    return s
end

# assign top-of-stack to p
procedure bc_gen_assign_to(s, p)
    local assign, call

    case type(p) of {
    default: { runerr(500, p) }
    "ir_Tmp": {
        bc_gen_ir_Tmp_assign(s, p)
    }
    "ir_Key": {
        bc_gen(s, p)
        assign := bc_Assign_methodref(bc_current_classptr)
        call := bc_CallN_methodref(bc_current_classptr, 0)
        put(s, j_invokevirtual(call))
        put(s, j_swap())
        put(s, j_invokevirtual(assign))
        put(s, j_pop())
    }
    "ir_Var" : {
        bc_gen(s, p)
        assign := bc_Assign_methodref(bc_current_classptr)
        put(s, j_swap())
        put(s, j_invokevirtual(assign))
        put(s, j_pop())
    }
    }
    return s
end


# record ir_Deref( lhs value )
procedure bc_gen_ir_Deref(s, p)
    local deref

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    (type(p.value) == "ir_Tmp") | runerr(500, p)

    bc_gen(s, p.value)
    deref := bc_Deref_methodref(bc_current_classptr)
    put(s, j_invokevirtual(deref))
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_Assign( lhs value )
procedure bc_gen_ir_Assign(s, p)
    local assign

    (type(p.target) == "ir_Tmp") | runerr(500, p)
    (type(p.value) == "ir_Tmp") | runerr(500, p)

    bc_gen(s, p.target)
    bc_gen(s, p.value)
    assign := bc_Assign_methodref(bc_current_classptr)
    put(s, j_invokevirtual(assign))
    put(s, j_pop() )
    return s
end

# record ir_Tmp( name )
procedure bc_gen_ir_Tmp_rval(s, p)
    put(s, j_Aload(bc_tmp_table[p.name] + bc_tmp_offset))
    return s
end
procedure bc_gen_ir_Tmp_assign(s, p)
    put(s, j_Astore(bc_tmp_table[p.name] + bc_tmp_offset))
    return s
end

# record ir_TmpLabel( name )
procedure bc_gen_ir_TmpLabel_rval(s, p)
    put(s, j_Iload(bc_tmplabel_table[p.name] + bc_tmplabel_offset))
    return s
end
procedure bc_gen_ir_TmpLabel_assign(s, p)
    put(s, j_Istore(bc_tmplabel_table[p.name] + bc_tmplabel_offset))
    return s
end

# record ir_Label( value )
procedure bc_gen_ir_Label_rval(s, p)

    member(bc_indirect_targets, p) | runerr(500)

    \bc_labels[p] | runerr(500, p)
    put(s, j_ipush(bc_labels[p], bc_current_classptr) )
    return s
end

# record ir_Field(coord, lhs, expr, field, failLabel)
procedure bc_gen_ir_Field(s, p)
    local lab, method, fieldname, field, d

    (/p.lhs | (type(p.lhs) == "ir_Tmp")) | runerr(500, p)
    (type(p.expr) == "ir_Tmp") | runerr(500, p)
    (/p.failLabel | type(p.failLabel) == "ir_Label") | runerr(500, p)
    if /bc_nodebuginfo then {
	bc_push_coordinate(s, p.coord)
    }
    bc_gen_rval(s, p.expr)
    d := j_cp_String(bc_current_classptr,
                   j_cp_Utf8(bc_current_classptr, p.field)) | runerr(500)
    put(s, j_ldc_w(d) )
    if \bc_nodebuginfo then {
        method := bc_Field_methodref(bc_current_classptr)
        put(s, j_invokevirtual(method))
    } else {
        method := bc_trampoline_Field_methodref(bc_current_classptr)
        put(s, j_invokestatic(method))
    }
    if \p.lhs then {
        put(s, j_dup() )
        lab := j_label()
        put(s, j_ifnonnull(lab) )
        put(s, j_pop() )
        bc_transfer_to(s, p.failLabel)
        put(s, lab )
        bc_gen_assign_to(s, p.lhs)
    } else {
        bc_conditional_transfer_to(s, p.failLabel, j_ifnull, j_ifnonnull)
    }
    return s
end

# record ir_Move( lhs rhs )
procedure bc_gen_ir_Move(s, p)
    local deref, call

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    (type(p.rhs) == "ir_Tmp") | runerr(500, p)

    bc_gen_rval(s, p.rhs)
    if type(p.rhs) == ("ir_Key") then {
        call := bc_CallN_methodref(bc_current_classptr, 0)
        put(s, j_invokevirtual(call))
    }
    if type(p.lhs) == ("ir_Key" | "ir_Var") then {
        deref := bc_Deref_methodref(bc_current_classptr)
        put(s, j_invokevirtual(deref))
    }
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_MoveLabel( lhs label )
procedure bc_gen_ir_MoveLabel(s, p)
    local deref, call

    (type(p.lhs) == "ir_TmpLabel") | runerr(500, p)
    (type(p.label) == "ir_Label") | runerr(500, p)
    \p.lhs | return s

    bc_gen_rval(s, p.label)
    bc_gen_ir_TmpLabel_assign(s, p.lhs)
    return s
end

# record ir_ScanSwap( subject pos )
procedure bc_gen_ir_ScanSwap(s, p)
    local subject, pos, Ksubject, Kpos, deref, assign, call

    (type(p.subject) == "ir_Tmp") | runerr(500, p)
    (type(p.pos) == "ir_Tmp") | runerr(500, p)
    call := bc_CallN_methodref(bc_current_classptr, 0)

    Ksubject := bc_gen_push_Key([], "subject")
    Kpos := bc_gen_push_Key([], "pos")

    subject := bc_gen([], p.subject)
    pos := bc_gen([], p.pos)

    deref := bc_Deref_methodref(bc_current_classptr)
    assign := bc_Assign_methodref(bc_current_classptr)
    every put(s, !Kpos)
    put(s, j_invokevirtual(deref))
    every put(s, !Ksubject)
    put(s, j_invokevirtual(deref))

    every put(s, !Ksubject)
    every put(s, !subject)
    put(s, j_invokevirtual(deref))
    put(s, j_invokevirtual(assign))
    put(s, j_pop())
    every put(s, !Kpos)
    every put(s, !pos)
    put(s, j_invokevirtual(deref))
    put(s, j_invokevirtual(assign))
    put(s, j_pop())

    bc_gen_assign_to(s, p.subject)
    bc_gen_assign_to(s, p.pos)
    return s
end

# record ir_Goto( targetLabel )
procedure bc_gen_ir_Goto(s, p)
    (type(p.targetLabel) == "ir_Label") | runerr(500, p)
    bc_transfer_to(s, p.targetLabel)
    return s
end

# record ir_IndirectGoto( targetTmpLabel )
procedure bc_gen_ir_IndirectGoto(s, p)
    (type(p.targetTmpLabel) == "ir_TmpLabel") | runerr(500, p)
    bc_transfer_to(s, p.targetTmpLabel)
    return s
end

# record ir_Var( lhs name )
procedure bc_gen_ir_Var_rval(s, p)

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    (type(p.name) == "string") | runerr(500, p)

    put(s, j_Aload(\bc_var_table[p.name] + bc_var_offset)) | runerr(500, p.name)
    bc_gen_assign_to(s, p.lhs)
    return s
end

procedure bc_gen_ir_Key_register(name)
    if /bc_keywords(name) then {
	semantic_error("invalid keyword" || " &" || name)
    }
    /bc_key_table[name] := j_create_fieldref(bc_current_classptr,
					       bc_keywords(name)[1],
					       bc_keywords(name)[2],
                                               "jcon/iKeyword")
end

procedure bc_gen_push_Key(s, name)
    local call

    (type(name) == "string") | runerr(500, name)
    bc_gen_ir_Key_register(name)
    put(s, j_getstatic(bc_key_table[name]))
    call := bc_CallN_methodref(bc_current_classptr, 0)
    put(s, j_invokevirtual(call))
    return s
end

# record ir_Key( lhs name failLabel )
procedure bc_gen_ir_Key(s, p)
    local target

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    (type(p.name) == "string") | runerr(500, p)
    (/p.failLabel | type(p.failLabel) == "ir_Label") | runerr(500, p)
    bc_gen_push_Key(s, p.name)
    ir_CallTail(s, p)
    return s
end

# record ir_IntLit( lhs val )
procedure bc_gen_ir_IntLit(s, p)
    local i, field

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    i := integer(p.val)
    /bc_integer_table[i] := "li$" || map(i, "-", "m")
    field := j_create_fieldref(bc_current_classptr, bc_integer_table[i],
                               "Ljcon/vNumeric;", bc_java_classname)
    put(s, j_getstatic(field))
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_RealLit( lhs val )
procedure bc_gen_ir_RealLit(s, p)
    local r, x, field

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    r := real(p.val)
    /bc_real_table[r] := "lr$" || map(r, ".-+", "dmp")
    field := j_create_fieldref(bc_current_classptr, bc_real_table[r],
                               "Ljcon/vReal;", bc_java_classname)
    put(s, j_getstatic(field))
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_StrLit( lhs val )
procedure bc_gen_ir_StrLit(s, p)
    local x, field

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    /bc_string_table[p.val] := "ls$" || *bc_string_table
    field := j_create_fieldref(bc_current_classptr, bc_string_table[p.val],
                             "Ljcon/vString;", bc_java_classname)
    put(s, j_getstatic(field))
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_CsetLit( lhs val )
procedure bc_gen_ir_CsetLit(s, p)
    local v, field

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    /bc_cset_table[p.val] := "lc$" || *bc_cset_table
    field := j_create_fieldref(bc_current_classptr, bc_cset_table[p.val],
                             "Ljcon/vCset;", bc_java_classname)
    put(s, j_getstatic(field))
    bc_gen_assign_to(s, p.lhs)
    return s
end

procedure bc_save_tmps(s)
    local a, k

    if *bc_tmp_table > 0 then {
        a := j_create_fieldref(bc_current_classptr, "tmpArray",
                             "[Ljcon/vDescriptor;", bc_current_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmp_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmp_table[k]))
            put(s, j_Aload(bc_tmp_table[k] + bc_tmp_offset))
            put(s, j_aastore())
        }
        put(s, j_pop())
    }
end

procedure bc_save_tmplabels(s)
    local a, k

    if *bc_tmplabel_table > 0 then {
        a := j_create_fieldref(bc_current_classptr, "tmpLabelArray", "[I",
                             bc_current_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmplabel_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmplabel_table[k]))
            put(s, j_Iload(bc_tmplabel_table[k] + bc_tmplabel_offset))
            put(s, j_iastore())
        }
        put(s, j_pop())
    }
end

# record ir_Succeed( expr resumeLabel coord )
procedure bc_gen_ir_Succeed(s, p)
    local r, e, PC, k, a
    local free, class_index
    local dereflocal

    (type(p.expr) == "ir_Tmp") | runerr(500, p)
    (/p.resumeLabel | type(p.resumeLabel) == "ir_Label") | runerr(500, p)
    PC := bc_PC_fieldref(bc_current_classptr, bc_vClosure_classname)
    if \p.resumeLabel then {
        \bc_save_restore_flag | runerr(500)

        put(s, j_aload_0())
        bc_gen(s, p.resumeLabel)
        put(s, j_putfield(PC))

        bc_save_tmps(s)
        bc_save_tmplabels(s)
    } else if \bc_save_restore_flag then {
        put(s, j_aload_0())
        put(s, j_iconst_0())
        put(s, j_putfield(PC))
    }
    bc_gen(s, p.expr)
    if \p.resumeLabel then {
        dereflocal := bc_DerefLocal_methodref(bc_current_classptr)
    } else {
        dereflocal := bc_Return_methodref(bc_current_classptr)
    }
    put(s, j_invokevirtual(dereflocal) )
    if /p.resumeLabel & \bc_stackptr then {
        free := bc_Free_methodref(bc_current_classptr)
        put(s, j_Aload(bc_stackptr + bc_var_offset))
	if \bc_save_restore_flag then {
            class_index := j_cp_Class(bc_current_classptr,
                              j_cp_Utf8(bc_current_classptr, "jcon/vLocalVar"))
	    put(s, j_checkcast(class_index))
	}
	put(s, j_invokestatic(free))
    }
    if /bc_nodebuginfo then {
	bc_emitlineinfo(s, p.coord, if /p.resumeLabel then 1 else -1)
    }
    put(s, j_areturn())
    return s
end

# record ir_Fail( coord )
procedure bc_gen_ir_Fail(s, p)
    local free, class_index

    if /bc_save_restore_flag & \bc_stackptr then {
        free := bc_Free_methodref(bc_current_classptr)
        put(s, j_Aload(bc_stackptr + bc_var_offset))
	if \bc_save_restore_flag then {
            class_index := j_cp_Class(bc_current_classptr,
                              j_cp_Utf8(bc_current_classptr, "jcon/vLocalVar"))
	    put(s, j_checkcast(class_index))
	}
	put(s, j_invokestatic(free))
    }
    if /bc_nodebuginfo then {
	bc_emitlineinfo(s, p.coord, 1)
    }
    put(s, j_aconst_null())
    put(s, j_areturn())
    return s
end

procedure bc_emitlineinfo(s, coord, factor)
    local field

    bc_push_coordinate(s, coord, factor)
    field := bc_line_fieldref(bc_current_classptr)
    put(s, j_putstatic(field) )
    field := bc_file_fieldref(bc_current_classptr)
    put(s, j_putstatic(field) )
end

# record ir_Unreachable( )
procedure bc_gen_ir_Unreachable(s, p)
    local runtimeerror

    runtimeerror := bc_error_methodref(bc_current_classptr)
    put(s, j_ipush(902))
    put(s, j_invokestatic(runtimeerror))
    put(s, j_aconst_null())
    put(s, j_areturn())
    return s
end

procedure bc_push_coordinate(s, coord, factor)
    local c, line

    if \coord then {
        c := j_cp_String(bc_current_classptr, j_cp_Utf8(bc_current_classptr, coord.file))
        put(s, j_ldc_w(c))
	line := coord.line
	line *:= \factor
	put(s, j_ipush(line) )
    } else {
        put(s, j_aconst_null() )
        put(s, j_iconst_0() )
    }
end

# record ir_ResumeValue( coord lhs value failLabel )
procedure bc_gen_ir_ResumeValue(s, p)
    local c, PC, target, resume, free

    (/p.lhs | type(p.lhs) == "ir_Tmp") | runerr(500, p)
    (type(p.value) == "ir_Tmp") | runerr(500, p)
    (/p.failLabel | type(p.failLabel) == "ir_Label") | runerr(500, p)
    if \bc_nodebuginfo then {
        resume := bc_Resume_methodref(bc_current_classptr)
        bc_gen(s, p.value)
        put(s, j_invokevirtual(resume))
    } else {
        resume := bc_trampoline_Resume_methodref(bc_current_classptr)
	bc_push_coordinate(s, p.coord)
        bc_gen(s, p.value)
        put(s, j_invokestatic(resume))
    }
    if \p.lhs then {
        put(s, j_dup())
        target := j_label()
        put(s, j_ifnonnull(target))
        put(s, j_pop())
        bc_transfer_to(s, p.failLabel)
        put(s, target)
        bc_gen_assign_to(s, p.lhs)
    } else {
        bc_conditional_transfer_to(s, p.failLabel, j_ifnull, j_ifnonnull)
    }
    return s
end

# record ir_MakeList( lhs valueList )
procedure bc_gen_ir_MakeList(s, p)
    local r, v, i, method, class_index

    \p.lhs | return s
    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    every i := !p.valueList do {
        (type(i) == "ir_Tmp") | runerr(500, p.valueList)
    }

    put(s, j_ipush(*p.valueList))
    class_index := j_cp_Class(bc_current_classptr,
                              j_cp_Utf8(bc_current_classptr,"jcon/vDescriptor"))
    put(s, j_anewarray(class_index) )

    every i := 1 to *p.valueList do {
        put(s, j_dup())
        put(s, j_ipush(i-1))
        bc_gen(s, p.valueList[i])
        put(s, j_aastore())
    }
    method := bc_New_vList_methodref(bc_current_classptr)
    put(s, j_invokestatic(method))
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_OpFunction( coord lhs fn argList failLabel )
procedure bc_gen_ir_OpFunction(s, p)
    local c, method, i

    (/p.lhs | type(p.lhs) == "ir_Tmp") | runerr(500, p)
    (/p.failLabel | type(p.failLabel) == "ir_Label") | runerr(500, p)
    every i := !p.argList do {
        (type(i) == "ir_Tmp") | runerr(500, p.argList)
    }

    p.fn.arity = *p.argList | runerr(500, p)
    if \bc_nodebuginfo then {
        method := bc_op_methodref(bc_current_classptr, p.fn.name, p.fn.arity, p.fn.rval)
        \method | runerr(500)
        every bc_gen(s, !p.argList)
        put(s, j_invokevirtual(method))
    } else {
	bc_push_coordinate(s, p.coord)
	if p.fn.name == "@" then {
            c := j_cp_String(bc_current_classptr, j_cp_Utf8(bc_current_classptr, bc_function_name))
            put(s, j_ldc_w(c))
	}
        method := bc_trampoline_op_methodref(bc_current_classptr, p.fn.name, p.fn.arity, p.fn.rval)
        \method | runerr(500)
        every bc_gen(s, !p.argList)
        put(s, j_invokestatic(method))
    }
    return ir_CallTail(s, p)
end

procedure ir_CallTail(s, p)
    local target

    if \p.failLabel then {
        if \p.lhs then {
            put(s, j_dup())
            target := j_label()
            put(s, j_ifnonnull(target))
            put(s, j_pop())
            bc_transfer_to(s, p.failLabel)
            put(s, target)
            bc_gen_assign_to(s, p.lhs)
        } else {
            bc_conditional_transfer_to(s, p.failLabel, j_ifnull, j_ifnonnull)
        }
    } else {
        if \p.lhs then {
            bc_gen_assign_to(s, p.lhs)
        } else {
            put(s, j_pop())
        }
    }
    return s
end

# record ir_Call( coord lhs fn argList failLabel )
procedure bc_gen_ir_Call(s, p)
    local r, l, f, v, n, i, method, class_index

    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    (type(p.fn) == "ir_Tmp") | runerr(500, p)
    (/p.failLabel | type(p.failLabel) == "ir_Label") | runerr(500, p)
    type(p.fn) ~== "ir_operator" | runerr(500, p)
    every i := !p.argList do {
        (type(i) == "ir_Tmp") | runerr(500, p.argList)
    }

    if /bc_nodebuginfo then {
	bc_push_coordinate(s, p.coord)
    }
    bc_gen(s, p.fn)
    if *p.argList <= 9 then {			#%#%#% hard-wired constant!!!!!
        every bc_gen(s, !p.argList)
        method := bc_CallN_methodref(bc_current_classptr, *p.argList)
    } else {
        put(s, j_ipush(*p.argList))
        class_index := j_cp_Class(bc_current_classptr,
                                  j_cp_Utf8(bc_current_classptr, "jcon/vDescriptor"))
        put(s, j_anewarray(class_index) )
        every i := 1 to *p.argList do {
            put(s, j_dup())
            put(s, j_ipush(i-1))
            bc_gen(s, p.argList[i])
            put(s, j_aastore())
        }
        method := bc_CallV_methodref(bc_current_classptr)
    }
    if \bc_nodebuginfo then {
        put(s, j_invokevirtual(method))
    } else {
        method := bc_trampoline_CallN_methodref(bc_current_classptr, *p.argList)
        put(s, j_invokestatic(method))
    }
    return ir_CallTail(s, p)
end

# record ir_operator( name arity )
procedure bc_gen_ir_operator(s, p)
    local n, x, field

    n := p.name || "," || p.arity
    /bc_op_table[n] := "proc_" || *bc_op_table
    field := j_create_fieldref(bc_current_classptr, bc_op_table[n],
                             "Ljcon/vDescriptor;", bc_java_classname)
    put(s, j_getstatic(field))
    return s
end

# record ir_Create( lhs coexpLabel )
procedure bc_gen_ir_Create(s, p)
    local class, init, newmethod, createmethod, vararray

    (type(p.lhs) == "ir_Tmp") | runerr(500, p)
    (type(p.coexpLabel) == "ir_Label") | runerr(500, p)
    bc_create_exists := 1

    \bc_save_restore_flag | runerr(500)

    if /p.lhs then {
	return s
    }

    class := j_cp_Class(bc_current_classptr, 
                        j_cp_Utf8(bc_current_classptr, bc_vClosure_classname))
    init := bc_initVI_methodref(bc_current_classptr, bc_vClosure_classname)
    newmethod := bc_New_vCoexp_methodref(bc_current_classptr)
    createmethod := bc_create_methodref(bc_current_classptr)
    vararray := j_create_fieldref(bc_current_classptr, "tmpVarArray",
                                  "[Ljcon/vDescriptor;", bc_current_classname)

    put(s, j_new(class))
    put(s, j_dup())
    put(s, j_aload_0() )
    put(s, j_getfield(vararray) )
    bc_gen(s, p.coexpLabel)
    put(s, j_invokespecial(init))
    put(s, j_invokestatic(newmethod))
    put(s, j_dup() )
    put(s, j_invokevirtual(createmethod))
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_CoRet( value resumeLabel )
procedure bc_gen_ir_CoRet(s, p)
    local c, r, coretmethod, current

    (type(p.value) == "ir_Tmp") | runerr(500, p)
    (type(p.resumeLabel) == "ir_Label") | runerr(500, p)
    if /bc_nodebuginfo then {
	bc_push_coordinate(s, p.coord)
        c := j_cp_String(bc_current_classptr, j_cp_Utf8(bc_current_classptr, bc_function_name))
        put(s, j_ldc_w(c))
    }
    current := bc_cur_coexp_fieldref(bc_current_classptr)
    put(s, j_getstatic(current))
    bc_gen(s, p.value)
    if \bc_nodebuginfo then {
        coretmethod := bc_coret_methodref(bc_current_classptr)
        put(s, j_invokevirtual(coretmethod))
    } else {
        coretmethod := bc_trampoline_coret_methodref(bc_current_classptr)
        put(s, j_invokestatic(coretmethod))
    }
    bc_transfer_to(s, p.resumeLabel)
    return s
end

# record ir_CoFail( )
procedure bc_gen_ir_CoFail(s, p)
    local c, cofailmethod, current

    if /bc_nodebuginfo then {
	bc_push_coordinate(s, p.coord)
        c := j_cp_String(bc_current_classptr, j_cp_Utf8(bc_current_classptr, bc_function_name))
        put(s, j_ldc_w(c))
    }
    current := bc_cur_coexp_fieldref(bc_current_classptr)
    put(s, j_getstatic(current))
    if \bc_nodebuginfo then {
        cofailmethod := bc_cofail_methodref(bc_current_classptr)
        put(s, j_invokevirtual(cofailmethod))
    } else {
        cofailmethod := bc_trampoline_cofail_methodref(bc_current_classptr)
        put(s, j_invokestatic(cofailmethod))
    }
    # the next two lines make the verifier happy.
    put(s, j_aconst_null())
    put(s, j_areturn())
    return s
end

# record ir_EnterInit( startLabel )
procedure bc_gen_ir_EnterInit(s, p)
    local target, initialized

    (type(p.startLabel) == "ir_Label") | runerr(500, p)
    j_create_field(bc_current_classptr, 8, "initialized", "Z")
    initialized := j_create_fieldref(bc_current_classptr, "initialized", "Z",
                                   bc_current_classname)
    put(s, j_getstatic(initialized))
    target := j_label()
    put(s, j_ifeq(target))
    bc_transfer_to(s, p.startLabel )
    put(s, target)
    put(s, j_iconst_1())
    put(s, j_putstatic(initialized))
    return s
end

procedure bc_gen_rval(s, p)
    return bc_gen(s, p)
end

procedure bc_gen(s, p)
    case type(p) of {
    "ir_Tmp" : return bc_gen_ir_Tmp_rval(s, p)
    "ir_TmpLabel" : return bc_gen_ir_TmpLabel_rval(s, p)
    "ir_Var" : return bc_gen_ir_Var_rval(s, p)
    "ir_Key" : return bc_gen_ir_Key(s, p)
    "ir_Label" : return bc_gen_ir_Label_rval(s, p)
    "ir_Deref" : return bc_gen_ir_Deref(s, p)
    "ir_Assign" : return bc_gen_ir_Assign(s, p)
    "ir_Move" : return bc_gen_ir_Move(s, p)
    "ir_MoveLabel" : return bc_gen_ir_MoveLabel(s, p)
    "ir_ScanSwap" : return bc_gen_ir_ScanSwap(s, p)
    "ir_Goto" : return bc_gen_ir_Goto(s, p)
    "ir_IndirectGoto" : return bc_gen_ir_IndirectGoto(s, p)
    "ir_IntLit" : return bc_gen_ir_IntLit(s, p)
    "ir_RealLit" : return bc_gen_ir_RealLit(s, p)
    "ir_StrLit" : return bc_gen_ir_StrLit(s, p)
    "ir_CsetLit" : return bc_gen_ir_CsetLit(s, p)
    "ir_Succeed" : return bc_gen_ir_Succeed(s, p)
    "ir_Fail" : return bc_gen_ir_Fail(s, p)
    "ir_ResumeValue" : return bc_gen_ir_ResumeValue(s, p)
    "ir_MakeList" : return bc_gen_ir_MakeList(s, p)
    "ir_OpFunction" : return bc_gen_ir_OpFunction(s, p)
    "ir_operator" : return bc_gen_ir_operator(s, p)
    "ir_Create" : return bc_gen_ir_Create(s, p)
    "ir_CoRet" : return bc_gen_ir_CoRet(s, p)
    "ir_CoFail" : return bc_gen_ir_CoFail(s, p)
    "ir_Unreachable" : return bc_gen_ir_Unreachable(s, p)
    "ir_EnterInit" : return bc_gen_ir_EnterInit(s, p)
    "ir_Field" : return bc_gen_ir_Field(s, p)
    "ir_Call" : return bc_gen_ir_Call(s, p)
    default : { runerr(500, p); }
    }
end

procedure bc_emit(label, code)
    return bc_emit_table[label] := code
end

procedure bc_invocables(all, L)
    every insert(bc_invoke_set, !L)
    bc_invoke_all := \all
end

procedure bc_links(L)
    every insert(bc_link_set, !L)
end

procedure bc_records(name, fields, coord)
    insert(bc_declare_set, name)
    bc_record_table[name] := fields
end

procedure bc_globals(L)
    every insert(bc_global_set, !L)
end

procedure bc_target_bookkeeping()
    local a, t, k

    bc_indirect_targets := set([])
    every a := !!bc_emit_table do {
        case type(a) of {
        "ir_CoRet":  t := a.resumeLabel
        "ir_Create": t := a.coexpLabel
        "ir_MoveLabel":   t := a.label
        "ir_Succeed":    t := a.resumeLabel
        default: next
        }
        if type(t) == "ir_Label" then {
            insert(bc_indirect_targets, t)
        }
    }
    every a := !!bc_emit_table & type(a) == "ir_Create" do {
        t := a.coexpLabel
        if type(t) == "ir_Label" then {
            insert(bc_indirect_targets, t)
        }
    }
    every k := !bc_indirect_targets do {
        /bc_labels[k] := *bc_labels + 1
        bc_ir2bc_labels[k] := j_label()
    }
    every k := key(bc_emit_table) do {
        /bc_labels[k] := *bc_labels + 1
        bc_ir2bc_labels[k] := j_label()
    }
end

procedure bc_find_save_restore(code)
    local a

    bc_save_restore_flag := &null
    if a := !!code & type(a)=="ir_Succeed" & \a.resumeLabel then {
        bc_save_restore_flag := 1
    }
    if a := !!code & type(a)=="ir_Create" then {
        bc_save_restore_flag := 1
    }
end

procedure bc_alloc_tmps(s, c, class, classname)
    local a, class_index

    if *bc_tmp_table > 0 then {
        put(s, j_aload_0() )
        put(s, j_ipush(*bc_tmp_table) )
        class_index := j_cp_Class(c, j_cp_Utf8(c, "jcon/vDescriptor"))
        put(s, j_anewarray(class_index) )
        a := j_create_fieldref(class, "tmpArray",
                             "[Ljcon/vDescriptor;", classname)
        put(s, j_putfield(a) )
    }
end

procedure bc_alloc_tmplabels(s, c, class, classname)
    local a
    if *bc_tmplabel_table > 0 then {
        put(s, j_aload_0() )
        put(s, j_ipush(*bc_tmplabel_table) )
        put(s, j_newarray(10) )
        a := j_create_fieldref(class, "tmpLabelArray", "[I",
                             classname)
        put(s, j_putfield(a) )
    }
end

procedure bc_function_variables(c, params, locals)
    local undeclared, k

    bc_locals_set := set(locals)
    bc_params_set := set(params)
    undeclared := bc_var_set -- bc_params_set -- bc_locals_set -- bc_statics_set
    return undeclared
end

procedure bc_function(name, params, accumulate, locals, statics, code,
                      codestart, lvalset, coord)
    local undeclared, op, i, classname, k, insns, nextval, c
    local f, n, a, t, superclass

    bc_function_name := name
    bc_lvalset := lvalset
    bc_stackptr := &null

    bc_statics_set := set(statics)
    insert(bc_declare_set, name)

    bc_proc_table[name] := if /accumulate then *params else -*params
    bc_args_set := set();
    bc_tmp_table := table()
    bc_tmplabel_table := table()
    bc_var_set := set([])
    bc_var_field := table()
    bc_var_table := table()
    bc_emit_table := table()
    bc_create_exists := &null
    bc_key_table := table()

    every i := !code do {
        bc_emit_table[i.label] := i.insnList
    }
    bc_labels := table()
    bc_ir2bc_labels := table()
    bc_labels[codestart] := 1

    bc_find_save_restore(bc_emit_table)

    bc_register(bc_emit_table)
    bc_target_bookkeeping()

    bc_tmp_offset := 15+2
    bc_tmplabel_offset := bc_tmp_offset + *bc_tmp_table
    bc_var_offset := bc_tmplabel_offset + *bc_tmplabel_table

    bc_vProc_classname    := "p_" || bc_java_classname || "$" || name
    bc_vClosure_classname := "c_" || bc_java_classname || "$" || name

    bc_current_classname := bc_vProc_classname
    c := bc_current_classptr := j_ClassFile(3, 45, [&null], table(), 16r11,
					&null, &null, [], [], [], [])
    superclass := "jcon/vProc" || ((/accumulate & 9 >= *params) | "V")
    c.super_class := j_cp_Class(c, j_cp_Utf8(c, superclass))
    c.this_class := j_cp_Class(c, j_cp_Utf8(c, bc_current_classname))

    undeclared := bc_function_variables(c, params, locals)
    bc_undeclared_table[name] := [coord.file, undeclared]
    if /bc_save_restore_flag then {
        every insert(bc_undeclared_set, !undeclared)
        bc_class_constructor(c, statics)
    }
    bc_create_Call(c, codestart, params, locals, undeclared, accumulate)
    bc_create_vProc_constructor(c, params, accumulate)

    f := open(bc_directory || bc_current_classname || ".class","wu") |
         runerr(500)
    j_writer_j_ClassFile(f, c)
    close(f)


    if \bc_save_restore_flag then {
        bc_current_classname := bc_vClosure_classname
        c := bc_current_classptr := j_ClassFile(3, 45, [&null], table(), 16r11,
					&null, &null, [], [], [], [])
        superclass := "jcon/vClosure"
        c.super_class := j_cp_Class(c, j_cp_Utf8(c, superclass))
        c.this_class := j_cp_Class(c, j_cp_Utf8(c, bc_current_classname))

        j_create_field(bc_current_classptr, 0, "PC", "I")
    
        undeclared := bc_function_variables(c, params, locals)
        every insert(bc_undeclared_set, !undeclared)
        bc_class_constructor(c, statics)
        bc_create_Resume(c, codestart, params, locals, undeclared, accumulate)

        bc_create_vClosure_constructor(c, params, locals, undeclared, accumulate)
        if \bc_create_exists then {
            j_create_field(bc_current_classptr, 0, "refreshArray", "[Ljcon/vDescriptor;")
            j_create_field(bc_current_classptr, 0, "refreshPC", "I")
            bc_create_vClosure_copy_constructor(c, params, locals, undeclared)
            bc_create_refresher(c)
        }

        f := open(bc_directory || bc_current_classname || ".class","wu") |
             runerr(500)
        j_writer_j_ClassFile(f, c)
        close(f)
    }
end

procedure bc_class_constructor(c, statics)
    local clinit, clinitcode, k, f, n, newsimplevar

    clinit := j_create_method(c, 8, "<clinit>", "()V")
    clinitcode := j_create_code(c, 15, 15)
    put(clinit.attributes, clinitcode)

    newsimplevar := bc_New_vSimpleVar_methodref(c)
    every k := !statics do {
        j_create_field(c, 8, "v$" || k, "Ljcon/vVariable;")
        f := j_create_fieldref(c, "v$" || k, "Ljcon/vVariable;",
                               bc_current_classname)
        n := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(clinitcode.code, j_ldc_w(n))
        put(clinitcode.code, j_invokestatic(newsimplevar))
        put(clinitcode.code, j_putstatic(f))
    }
    put(clinitcode.code, j_return() )
end

procedure bc_create_vProc_constructor(c, params, accumulate)
    local init, initcode, constructor, createvars, s, superclass

    init := j_create_method(c, 1, "<init>", "()V")
    initcode := j_create_code(c, 15, 15)
    put(init.attributes, initcode)
    s := initcode.code
    superclass := "jcon/vProc" || ((/accumulate & 9 >= *params) | "V")
    constructor := bc_init_methodref(c, superclass)
    put(s, j_aload_0() )
    put(s, j_invokespecial(constructor) )
    put(s, j_return() )
end

procedure bc_create_vClosure_constructor(c, params, locals, undeclared, accumulate)
    local init, initcode, constructor, createvars, s, superclass, PC
    local class_index, vararray

    init := j_create_method(c, 1, "<init>", "([Ljcon/vDescriptor;)V")
    initcode := j_create_code(c, 15, 15)
    put(init.attributes, initcode)
    s := initcode.code

    if *bc_tmp_table > 0 then {
        j_create_field(bc_current_classptr, 0, "tmpArray",
                       "[Ljcon/vDescriptor;")
    }
    if *bc_tmplabel_table > 0 then {
        j_create_field(bc_current_classptr, 0, "tmpLabelArray", "[I")
    }
    j_create_field(bc_current_classptr, 0, "tmpVarArray",
                       "[Ljcon/vDescriptor;")

    superclass := "jcon/vClosure"
    constructor := bc_init_methodref(c, superclass)
    put(s, j_aload_0() )
    put(s, j_invokespecial(constructor) )
    vararray := j_create_fieldref(bc_current_classptr, "tmpVarArray",
                                  "[Ljcon/vDescriptor;", bc_current_classname)
    put(s, j_aload_0() )
    put(s, j_aload_1() )
    put(s, j_putfield(vararray) )
    PC := bc_PC_fieldref(bc_current_classptr, bc_vClosure_classname)
    put(s, j_aload_0() )
    put(s, j_iconst_1() )
    put(s, j_putfield(PC) )

    bc_alloc_tmps(s, c, bc_current_classptr, bc_current_classname)
    bc_alloc_tmplabels(s, c, bc_current_classptr, bc_current_classname)

    put(s, j_return() )
end

procedure bc_create_refresher(c)
    local refresher, code, s, class, init, refreshArray, refreshPC

    refresher := j_create_method(c, 1, "refreshcopy", "()Ljcon/vClosure;")
    code := j_create_code(c, 15, 15)
    put(refresher.attributes, code)
    s := code.code

    class := j_cp_Class(c, j_cp_Utf8(c, bc_vClosure_classname))
    init := bc_initVI_methodref(c, bc_vClosure_classname)
    refreshArray := bc_refreshArray_fieldref(c, bc_vClosure_classname)
    refreshPC := bc_refreshPC_fieldref(c, bc_vClosure_classname)

    put(s, j_new(class))
    put(s, j_dup())
    put(s, j_aload_0() )
    put(s, j_getfield(refreshArray) )
    put(s, j_aload_0() )
    put(s, j_getfield(refreshPC) )
    put(s, j_invokespecial(init))
    put(s, j_areturn() )
end

procedure bc_create_vClosure_copy_constructor(c, params, locals, undeclared)
    local init, initcode, constructor, createvars, s, superclass, PC
    local class_index, vararray, v
    local newsimplevar, k, linkvalue, lab1, refresharray, deref

    init := j_create_method(c, 1, "<init>", "([Ljcon/vDescriptor;I)V")
    initcode := j_create_code(c, 15, 15)
    put(init.attributes, initcode)
    s := initcode.code
    superclass := "jcon/vClosure"
    constructor := bc_init_methodref(c, superclass)
    put(s, j_aload_0() )
    put(s, j_invokespecial(constructor) )
    vararray := j_create_fieldref(bc_current_classptr, "tmpVarArray",
                                  "[Ljcon/vDescriptor;", bc_current_classname)
    refresharray := bc_refreshArray_fieldref(bc_current_classptr, bc_current_classname)
    newsimplevar := bc_New_Local_Assign_Unstacked_methodref(c)
    # newsimplevar := bc_New_vSimpleVar_Assign_methodref(c)
    class_index := j_cp_Class(bc_current_classptr,
                              j_cp_Utf8(bc_current_classptr,"jcon/vDescriptor"))
    deref := bc_Deref_methodref(c)

    put(s, j_aload_0() )
    put(s, j_ipush(*bc_var_table) )
    put(s, j_anewarray(class_index) )
    put(s, j_putfield(vararray) )

    put(s, j_aload_0() )
    put(s, j_ipush(*bc_var_table) )
    put(s, j_anewarray(class_index) )
    put(s, j_putfield(refresharray) )

    every k := (!params|!locals) & \bc_var_table[k] do {
        put(s, j_aload_0() )
        put(s, j_getfield(vararray) )
        put(s, j_ipush(bc_var_table[k]) )
        v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_ldc_w(v) )
        put(s, j_aload_1() )
        put(s, j_ipush(bc_var_table[k]) )
        put(s, j_aaload() )
        put(s, j_invokestatic(newsimplevar) )
        put(s, j_aastore() )
    }
    every k := !undeclared do {
        put(s, j_aload_0() )
        put(s, j_getfield(vararray) )
        put(s, j_ipush(bc_var_table[k]) )
        linkvalue := j_create_fieldref(c, "v$" || k ||"$", "Ljcon/vVariable;",
                                     bc_java_classname)
        lab1 := j_label()
        put(s, j_getstatic(linkvalue) )
        put(s, j_dup() )
        put(s, j_ifnonnull(lab1) )
        put(s, j_pop() )
        v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_ldc_w(v) )
        put(s, j_aload_1() )
        put(s, j_ipush(bc_var_table[k]) )
        put(s, j_aaload() )
        put(s, j_invokestatic(newsimplevar) )
        put(s, lab1 )
        put(s, j_aastore() )
    }
    every k := (!params|!locals|!undeclared) & \bc_var_table[k] do {
        put(s, j_aload_0() )
        put(s, j_getfield(refresharray) )
        put(s, j_ipush(bc_var_table[k]) )
        put(s, j_aload_1() )
        put(s, j_ipush(bc_var_table[k]) )
        put(s, j_aaload() )
        put(s, j_invokevirtual(deref) )
        put(s, j_aastore() )
    }

    PC := bc_PC_fieldref(bc_current_classptr, bc_vClosure_classname)
    put(s, j_aload_0() )
    put(s, j_iload_2() )
    put(s, j_putfield(PC) )
    put(s, j_aload_0() )
    put(s, j_iload_2() )
    PC := bc_refreshPC_fieldref(bc_current_classptr, bc_vClosure_classname)
    put(s, j_putfield(PC) )

    bc_alloc_tmps(s, c, bc_current_classptr, bc_current_classname)
    bc_alloc_tmplabels(s, c, bc_current_classptr, bc_current_classname)

    put(s, j_return() )
end

procedure bc_register(t)
    local op

    every op := !!!t do {
        bc_register0(op)
    }
    every op := !!t do {
        bc_register0(op)
    }
end

procedure bc_register0(op)
    case type(op) of {
    "list" : every bc_register0(!op)
    "ir_Tmp" :        /bc_tmp_table[op.name] := *bc_tmp_table;
    "ir_TmpLabel" :   /bc_tmplabel_table[op.name] := *bc_tmplabel_table
    "ir_Var" : {
                     insert(bc_var_set, op.name)
                     /bc_var_table[op.name] := *bc_var_table
    }
    }
end

procedure bc_restore_tmps(s)
    local a, k

    if *bc_tmp_table > 0 then {
        a := j_create_fieldref(bc_current_classptr, "tmpArray",
                             "[Ljcon/vDescriptor;", bc_current_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmp_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmp_table[k]))
            put(s, j_aaload())
            put(s, j_Astore(bc_tmp_table[k] + bc_tmp_offset))
        }
        put(s, j_pop())
    }
end

procedure bc_restore_tmplabels(s)
    local a, k

    if *bc_tmplabel_table > 0 then {
        a := j_create_fieldref(bc_current_classptr, "tmpLabelArray", "[I",
                             bc_current_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmplabel_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmplabel_table[k]))
            put(s, j_iaload())
            put(s, j_Istore(bc_tmplabel_table[k] + bc_tmplabel_offset))
        }
        put(s, j_pop())
    }
end

procedure bc_create_Resume(c, start, params, locals, undeclared, accumulate)
    local nextval, nextvalcode

    nextval := j_create_method(c, 0, "Resume", "()Ljcon/vDescriptor;")
    nextvalcode := j_create_code(c, 15, 15)
    put(nextval.attributes, nextvalcode)
    bc_nextval_code(nextvalcode, c, start, params, locals, undeclared,
                    accumulate)
end

procedure bc_create_Call(c, start, params, locals, undeclared, accumulate)
    local nextval, nextvalcode

    if \accumulate | (*params > 9) then {
        nextval := j_create_method(c, 0, "Call", "([Ljcon/vDescriptor;)Ljcon/vDescriptor;")
    } else {
        nextval := bc_CallN_method(c, *params)
    }
    nextvalcode := j_create_code(c, 15, 15)
    put(nextval.attributes, nextvalcode)
    if \bc_save_restore_flag then {
        bc_trampoline(nextvalcode, c, params, locals, undeclared, accumulate)
    } else {
        bc_nextval_code(nextvalcode, c, start, params, locals, undeclared,
                        accumulate)
    }
end

procedure bc_trampoline(nextvalcode, c, params, locals, undeclared, accumulate)
    local s, class, init, resume, target, retval

    s := nextvalcode.code
    class := j_cp_Class(c, j_cp_Utf8(c, bc_vClosure_classname))
    init := bc_initV_methodref(c, bc_vClosure_classname) 
    resume := bc_Resume_methodref(c)
    retval := bc_retval_fieldref(c)
    target := j_label()

    put(s, j_new(class))
    put(s, j_dup())

    bc_createvars_into_array(s, c, params, locals, undeclared, accumulate)

    put(s, j_invokespecial(init))
    put(s, j_dup())
    put(s, j_dup())
    put(s, j_invokevirtual(resume) )
    put(s, j_dup() )
    put(s, j_ifnull(target) )
    put(s, j_putfield(retval) )
    put(s, j_areturn() )

    put(s, target)
    put(s, j_aconst_null() )
    put(s, j_areturn())
end

procedure bc_nextval_code(nextvalcode, c, start, params, locals, undeclared, accumulate)
    local k, lab, switch, insns, deflab
    local runtimeerror, r, s, PC
    local a, tmplab, prologue, var_load_label, t, tmpset
    local last_label, i, endlab, class_index, f, beginlab

    nextvalcode.max_locals := bc_var_offset + *bc_var_table
    s := nextvalcode.code

    bc_switch_label := j_label()
    var_load_label := j_label()
    tmplab := j_label()

    beginlab := j_label()
    endlab := j_label()

    if \bc_save_restore_flag then {
        PC := bc_PC_fieldref(c, bc_vClosure_classname)
        bc_restore_tmps(s)
        bc_restore_tmplabels(s)
        bc_load_variables(s)
        put(s, j_aload_0() )
        put(s, j_getfield(PC))
    } else {
        bc_createvars(s, c, params, locals, undeclared, accumulate)
        bc_load_statics(s)
        bc_initialize_tmps(s)
    }

    if \bc_nodebuginfo then {
	put(s, j_goto(beginlab))
        bc_emit_exception(c, s, params, nextvalcode.exception_table, beginlab, endlab)
    }


    put(s, beginlab)

    deflab := j_label()
    member(bc_indirect_targets, start) & runerr(500)
    switch := j_tableswitch(0, deflab, 1, *bc_indirect_targets+1,
                          list(*bc_indirect_targets+1))

    if \bc_save_restore_flag then {
        put(s, j_goto_w(bc_switch_label) )
    }
    bc_emit_code(s, switch, start)
    every k := (!bc_indirect_targets | start) do {
        switch.offsets[\bc_labels[k]] :=
                   if member(bc_emitted, k) then \bc_ir2bc_labels[k] else deflab
    }
    put(s, bc_switch_label)
    #%#% the bc_tmplabel_table test below is because dead code can contain
    #%#% indirect jumps for which there is no corresponding tmplabel assignment
    if (*bc_indirect_targets > 0) | (*bc_tmplabel_table > 0) then {
        put(s, switch)
        runtimeerror := bc_error_methodref(c)
        put(s, deflab)
        # put(s, j_ipush(902) )			#%#% disabled as temporary hack
        # put(s, j_invokestatic(runtimeerror) )	#%#% to fix return/suspend bug
        put(s, j_aconst_null())
        put(s, j_areturn())
    } else {
        /bc_save_restore_flag | runerr(500)
    }
    put(s, endlab)

end

procedure bc_emit_exception(c, s, params, etab, last_label, i)
    local catch_type, lab, e, f, coord, class_index, k, propagate, v

    catch_type := j_cp_Class(bc_current_classptr,
                             j_cp_Utf8(bc_current_classptr, "jcon/iError"))
    lab := j_label()
    e := j_exception_table_info(last_label, i, lab, catch_type)
    put(etab, e)
    put(s, lab)

    v := j_cp_String(bc_current_classptr, j_cp_Utf8(bc_current_classptr, bc_function_name))
    put(s, j_ldc_w(v) )

    put(s, j_ipush(*params))
    class_index := j_cp_Class(bc_current_classptr,
                              j_cp_Utf8(bc_current_classptr,"jcon/vDescriptor"))
    put(s, j_anewarray(class_index) )
    every i := 1 to *params do {
        k := params[i]
        put(s, j_dup() )
        put(s, j_ipush(i-1) )
        if \bc_var_table[k] then {
            put(s, j_Aload(bc_var_table[k]+bc_var_offset) )
        } else {
	    put(s, j_aconst_null() )
        }
        put(s, j_aastore() )
    }

    propagate := bc_propagate_methodref(c)
    put(s, j_invokevirtual(propagate) )
    put(s, j_aconst_null() )
    put(s, j_areturn() )
end

procedure bc_load_variables(s)
    local k, vararray

    every k := key(bc_var_table) do {
        /bc_var_field[k] := j_create_fieldref(bc_current_classptr, "v$" || k,
                                            "Ljcon/vVariable;",
                                            bc_current_classname)
        if member(bc_statics_set, k) then {
            put(s, j_getstatic(bc_var_field[k]))
        } else {
            vararray := j_create_fieldref(bc_current_classptr, "tmpVarArray",
                                  "[Ljcon/vDescriptor;", bc_current_classname)
            put(s, j_aload_0() )
            put(s, j_getfield(vararray) )
            put(s, j_ipush(bc_var_table[k]) )
            put(s, j_aaload() )
        }
        put(s, j_Astore(bc_var_table[k] + bc_var_offset))
    }
end

procedure bc_load_statics(s)
    local k

    every k := key(bc_var_table) & member(bc_statics_set, k) do {
        /bc_var_field[k] := j_create_fieldref(bc_current_classptr, "v$" || k,
                                            "Ljcon/vVariable;",
                                            bc_current_classname)
        put(s, j_getstatic(bc_var_field[k]))
        put(s, j_Astore(bc_var_table[k] + bc_var_offset))
    }
end

procedure bc_initialize_tmps(s)
    local k

    every k := key(bc_tmp_table) do {
        put(s, j_aconst_null())
        put(s, j_Astore(bc_tmp_table[k] + bc_tmp_offset))
    }
    every k := key(bc_tmplabel_table) do {
        put(s, j_iconst_0())
        put(s, j_Istore(bc_tmplabel_table[k] + bc_tmplabel_offset))
    }
end

global bc_emitted

procedure bc_emit_code0(s, switch, k)
    local lab, insns, i

    if member(bc_emitted, k) then return
    insert(bc_emitted, k)

    lab := bc_ir2bc_labels[k]
    put(s, lab)
    insns := bc_emit_table[k]
    \insns | runerr(500, k)
    every i := insns[1 to *insns-1] do {
        bc_gen(s, i)
    }
    if type(insns[-1]) == "ir_Goto" &
       type(insns[-1].targetLabel) == "ir_Label" &
       not member(bc_emitted, insns[-1].targetLabel) then {
        bc_emit_code0(s, switch, insns[-1].targetLabel)
    } else {
        bc_gen(s, insns[-1])
    }
end

procedure bc_emit_code(s, switch, start)
    bc_emitted := set([])
    bc_emit_code0(s, switch, start)
    every bc_emit_code0(s, switch, key(bc_emit_table))
end

procedure bc_emit_param_val(s, c, params, accumulate, i)
    local marshal, k, field, elselab, endlab, newsimplevar
    local null, assign

    null := bc_New_vNull_methodref(bc_current_classptr)

    if \accumulate | (*params > 9) then {	#%#%#% hard-wired constant!!!!
        if i = *params & \accumulate then {
            marshal := bc_marshal_methodref(c)
            put(s, j_aload_1() )	#%#%# arguments array
            put(s, j_ipush(*params))
            put(s, j_invokestatic(marshal))
        } else {
            elselab := j_label()
            endlab := j_label()
            put(s, j_aload_1() )	#%#%# arguments array
            put(s, j_arraylength())
            put(s, j_ipush(i))
            put(s, j_if_icmpge(elselab))
                put(s, j_invokestatic(null))
                put(s, j_goto(endlab))
            put(s, elselab)
                put(s, j_aload_1() )	#%#%# arguments array
                put(s, j_ipush(i-1))
                put(s, j_aaload())
            put(s, endlab)
        }
    } else {
        put(s, j_Aload(i))
    }
end

procedure bc_createvars_into_array(s, c, params, locals, undeclared, accumulate)
    local newsimplevar, k, field, v, i, deref
    local linkvalue, lab1, class_index

    put(s, j_ipush(*bc_var_table))
    class_index := j_cp_Class(bc_current_classptr,
                              j_cp_Utf8(bc_current_classptr,"jcon/vDescriptor"))
    put(s, j_anewarray(class_index) )

    newsimplevar := bc_New_Local_Assign_methodref(c)
    deref := bc_Deref_methodref(c)
    every i := 1 to *params do {
        k := params[i]
        if \bc_var_table[k] then {
            put(s, j_dup() )
            put(s, j_ipush(bc_var_table[k]) )
	    if member(bc_lvalset, k) then {
	        /bc_stackptr := bc_var_table[k]
                v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
                put(s, j_ldc_w(v) )
                bc_emit_param_val(s, c, params, accumulate, i)
                put(s, j_invokestatic(newsimplevar) )
	    } else {
                bc_emit_param_val(s, c, params, accumulate, i)
                put(s, j_invokevirtual(deref) )
	    }
            put(s, j_aastore() )
        }
    }

    newsimplevar := bc_New_Local_methodref(c)
    every k := !locals do {
        if \bc_var_table[k] then {
	    /bc_stackptr := bc_var_table[k]
            put(s, j_dup() )
            put(s, j_ipush(bc_var_table[k]) )
            v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
            put(s, j_ldc_w(v) )
            put(s, j_invokestatic(newsimplevar) )
            put(s, j_aastore() )
        }
    }

    every k := !undeclared do {
        put(s, j_dup() )
        put(s, j_ipush(bc_var_table[k]) )

        linkvalue := j_create_fieldref(c, "v$" || k ||"$", "Ljcon/vVariable;",
                                     bc_java_classname)
        lab1 := j_label()
        v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_getstatic(linkvalue) )
        put(s, j_dup() )
        put(s, j_ifnonnull(lab1) )
        put(s, j_pop() )
        put(s, j_ldc_w(v) )
        put(s, j_invokestatic(newsimplevar) )
        put(s, lab1 )
        put(s, j_aastore() )
    }
end

procedure bc_createvars(s, c, params, locals, undeclared, accumulate)
    local newsimplevar, k, field, v, i, deref
    local linkvalue, lab1

    newsimplevar := bc_New_Local_Assign_methodref(c)
    deref := bc_Deref_methodref(c)
    every i := 1 to *params do {
        k := params[i]
        if \bc_var_table[k] then {
	    if member(bc_lvalset, k) then {
	        /bc_stackptr := bc_var_table[k]
                v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
                put(s, j_ldc_w(v) )
                bc_emit_param_val(s, c, params, accumulate, i)
                put(s, j_invokestatic(newsimplevar) )
	    } else {
                bc_emit_param_val(s, c, params, accumulate, i)
                put(s, j_invokevirtual(deref) )
	    }
            put(s, j_Astore(bc_var_table[k] + bc_var_offset))
        }
    }

    newsimplevar := bc_New_Local_methodref(c)
    every k := !locals do {
        if \bc_var_table[k] then {
	    /bc_stackptr := bc_var_table[k]
            v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
            put(s, j_ldc_w(v) )
            put(s, j_invokestatic(newsimplevar) )
            put(s, j_Astore(bc_var_table[k] + bc_var_offset))
        }
    }

    every k := !undeclared do {
        linkvalue := j_create_fieldref(c, "v$" || k ||"$", "Ljcon/vVariable;",
                                     bc_java_classname)
        lab1 := j_label()
        v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_getstatic(linkvalue) )
        put(s, j_dup() )
        put(s, j_ifnonnull(lab1) )
        put(s, j_pop() )
        put(s, j_ldc_w(v) )
        put(s, j_invokestatic(newsimplevar) )
        put(s, lab1 )
        put(s, j_Astore(bc_var_table[k] + bc_var_offset))
    }
end

procedure bc_copy_variable(s, c, k)
    local deref, assign, field

    deref := bc_Deref_methodref(c)
    assign := bc_Assign_methodref(bc_current_classptr)
    field := j_create_fieldref(c, "v$" || k, "Ljcon/vVariable;",
                               bc_current_classname)
    put(s, j_aload_2() )
    put(s, j_getfield(field) )
    put(s, j_aload_0() )
    put(s, j_getfield(field) )
    put(s, j_invokevirtual(deref) )
    put(s, j_invokevirtual(assign) )
    put(s, j_pop())
end

procedure bc_process_flags(flagList)
    local k

    if "-debug" == !flagList then {
        bc_debug := 1
    }

    !flagList ? {
        ="-class:" & bc_java_classname := tab(0)
    }
    \bc_java_classname | stop("ERROR: must specify -class:<name>")

    bc_nodebuginfo := 1
    every k := !flagList do {
        k ? {
            if ="-f" then {
		if upto('aden') then {
                    bc_nodebuginfo := &null
                }
            }
        }
    }

    bc_directory := "./"
    bc_directory := (!flagList ? (="-dir:" & tab(0)))
end

procedure bc_File(irgen, flagList)
    local k, i, op, c, f, p

    bc_process_flags(flagList)

    bc_invoke_set := set([])
    bc_invoke_all := &null
    bc_link_set := set([])
    bc_global_set := set([])
    bc_proc_table := table()
    bc_record_table := table()
    bc_undeclared_set := set([])
    bc_undeclared_table := table()
    bc_op_table := table()
    bc_declare_set := set([])

    bc_cset_table := table()
    bc_string_table := table()
    bc_integer_table := table()
    bc_real_table := table()

    while p := @irgen do {
        case type(p) of {
        "ir_Global"    : bc_globals(p.nameList)
        "ir_Record"    : bc_records(p.name, p.fieldList)
        "ir_Invocable" : bc_invocables(p.all, p.nameList)
        "ir_Function"  : bc_function(p.name, p.paramList, p.accumulate,
                                    p.localList, p.staticList, p.codeList,
                                    p.codeStart, p.lvalset, p.coord)
        "ir_Link"      : bc_links(p.nameList)
        default       : runerr(500, p)
        }
    }

    c := j_ClassFile(3, 45, [&null], table(), 16r11, &null,
                                         &null, [], [], [], [])
    c.super_class := j_cp_Class(c, j_cp_Utf8(c, "jcon/iFile"))
    c.this_class := j_cp_Class(c, j_cp_Utf8(c, bc_java_classname))

    bc_create_declare(c)
    bc_create_unresolved(c)
    bc_create_announce_unresolved(c)
    bc_create_linked(c)
    bc_create_resolve(c)
    bc_create_linkinit(c)
    bc_create_class_linkinit(c)

    f := open(bc_directory || bc_java_classname || ".class","wu") | runerr(500)
    j_writer_j_ClassFile(f, c)
    close(f)
end

procedure bc_create_declare(c)
    local declare, declarecode, declareGlobal, k, s, declareProcedure
    local declareRecord, stringclass, i, f, nm
    local class, init
    local declareDebugging

    declare := j_create_method(c, 0, "declare", "()V")
    declarecode := j_create_code(c, 15, 15)
    put(declare.attributes, declarecode)

    if /bc_nodebuginfo then {
        declareDebugging := bc_declareDebugging_methodref(c)
        put(declarecode.code, j_invokestatic(declareDebugging) )
    }
    declareGlobal := bc_declareGlobal_methodref(c)
    every k := !bc_global_set do {
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, j_ldc_w(s) )
        put(declarecode.code, j_invokestatic(declareGlobal) )
    }

    declareProcedure := bc_declareProcedure_methodref(c)
    every k := key(bc_proc_table) do {
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, j_ldc_w(s) )

	nm := "p_" || bc_java_classname || "$" || k
        class := j_cp_Class(c, j_cp_Utf8(c, nm))
        init := bc_init_methodref(c, nm)
        put(declarecode.code, j_new(class) )
        put(declarecode.code, j_dup() )
        put(declarecode.code, j_invokespecial(init) )

        put(declarecode.code, j_ipush(bc_proc_table[k]) )
        put(declarecode.code, j_invokestatic(declareProcedure) )
    }

    declareRecord := bc_declareRecord_methodref(c)
    stringclass := j_cp_Class(c, j_cp_Utf8(c, "java/lang/String"))
    every k := key(bc_record_table) do {
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, j_ldc_w(s) )

        put(declarecode.code, j_ipush(*bc_record_table[k]) )
        put(declarecode.code, j_anewarray(stringclass) )
        every i := 1 to *bc_record_table[k] do {
            put(declarecode.code, j_dup() )
            put(declarecode.code, j_ipush(i-1) )
            f := j_cp_String(c, j_cp_Utf8(c, bc_record_table[k][i])) |
                 runerr(500)
            put(declarecode.code, j_ldc_w(f) )
            put(declarecode.code, j_aastore() )
        }
        put(declarecode.code, j_invokestatic(declareRecord) )
    }
    put(declarecode.code, j_return() )
end

procedure bc_create_unresolved(c)
    local unresolved, unresolvedcode, invokeall, invokes, k, s
    local undeclaredmethod

    unresolved := j_create_method(c, 0, "unresolved", "()V")
    unresolvedcode := j_create_code(c, 15, 15)
    put(unresolved.attributes, unresolvedcode)

    if \bc_invoke_all then {
        invokeall := bc_declareInvokeAll_methodref(c)
        put(unresolvedcode.code, j_invokestatic(invokeall) )
    } else {
        invokes := bc_declareInvoke_methodref(c)
        every k := !bc_invoke_set do {
            s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
            put(unresolvedcode.code, j_ldc_w(s) )
            put(unresolvedcode.code, j_invokestatic(invokes) )
        }
    }

    undeclaredmethod := bc_undeclared_methodref(c)
    every k := !bc_undeclared_set do {
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(unresolvedcode.code, j_ldc_w(s) )
        put(unresolvedcode.code, j_invokestatic(undeclaredmethod) )
    }
    put(unresolvedcode.code, j_return() )
end

procedure bc_create_announce_unresolved(c)
    local unresolved, unresolvedcode, invokeall, invokes, k, s
    local undeclaredmethod
    local file, tuple, n

    unresolved := j_create_method(c, 0, "announce_unresolved", "()V")
    unresolvedcode := j_create_code(c, 15, 15)
    put(unresolved.attributes, unresolvedcode)

    undeclaredmethod := bc_announce_undeclared_methodref(c)
    every k := key(bc_undeclared_table) do {
	tuple := bc_undeclared_table[k]
	file := tuple[1]
	every n := !tuple[2] do {
            s := j_cp_String(c, j_cp_Utf8(c, n))
            put(unresolvedcode.code, j_ldc_w(s) )
            s := j_cp_String(c, j_cp_Utf8(c, k))
            put(unresolvedcode.code, j_ldc_w(s) )
            s := j_cp_String(c, j_cp_Utf8(c, file))
            put(unresolvedcode.code, j_ldc_w(s) )
            put(unresolvedcode.code, j_invokestatic(undeclaredmethod) )
	}
    }
    put(unresolvedcode.code, j_return() )
end

procedure bc_create_linked(c)
    local linked, linkedcode, linkref, lab, linkmethod, k, s, f
    local linkclassname, ifile, constructor

    if *bc_link_set > 0 then {
        j_create_field(c, 8, "linked", "Z")

        linked := j_create_method(c, 0, "link", "()V")
        linkedcode := j_create_code(c, 15, 15)
        put(linked.attributes, linkedcode)

        linkref := j_create_fieldref(c, "linked", "Z", bc_java_classname)
        put(linkedcode.code, j_getstatic(linkref) )
        lab := j_label()
        put(linkedcode.code, j_ifne(lab) )
        put(linkedcode.code, j_iconst_1() )
        put(linkedcode.code, j_putstatic(linkref) )
        linkmethod := bc_link_methodref(c)

        every k := !bc_link_set do {
	    linkclassname := "l$" || k
	    ifile := j_cp_Class(c, j_cp_Utf8(c, linkclassname))
	    put(linkedcode.code, j_new(ifile) )
	    put(linkedcode.code, j_dup() )
            constructor := bc_init_methodref(c, linkclassname)
            put(linkedcode.code, j_invokespecial(constructor) )
            s := j_cp_String(c, j_cp_Utf8(c, linkclassname))
            put(linkedcode.code, j_ldc_w(s) )
            put(linkedcode.code, j_invokestatic(linkmethod) )
        }

        put(linkedcode.code, lab )
        put(linkedcode.code, j_return() )
    }
    f := open(bc_directory || "links", "w") | runerr(500)
    every k := !bc_link_set do {
        write(f, k)
    }
    close(f)
end

procedure bc_create_resolve(c)
    local resolve, resolvecode, resolvemethod, k, f, s, op

    resolve := j_create_method(c, 0, "resolve", "()V")
    resolvecode := j_create_code(c, 15, 15)
    put(resolve.attributes, resolvecode)

    resolvemethod := bc_resolve_methodref(c)
    every k := !bc_undeclared_set do {
        f := j_create_fieldref(c, "v$" || k || "$", "Ljcon/vVariable;",
                             bc_java_classname)
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(resolvecode.code, j_ldc_w(s) )
        put(resolvecode.code, j_invokestatic(resolvemethod) )
        put(resolvecode.code, j_putstatic(f) )
    }

    resolvemethod := bc_resolveProc_methodref(c)
    every k := key(bc_op_table) do {
        k ? {
            op := tab(upto(','))
            move(1)
            args := integer(tab(0))
        }
        f := j_create_fieldref(c, bc_op_table[k], "Ljcon/vDescriptor;",
                             bc_java_classname)
        s := j_cp_String(c, j_cp_Utf8(c, op)) | runerr(500)
        put(resolvecode.code, j_ldc_w(s) )
        put(resolvecode.code, j_ipush(args) )
        put(resolvecode.code, j_invokestatic(resolvemethod) )
        put(resolvecode.code, j_putstatic(f) )
    }
    put(resolvecode.code, j_return() )
end

procedure bc_create_linkinit(c)
    local init, initcode, constructor, s

    init := j_create_method(c, 1, "<init>", "()V")
    initcode := j_create_code(c, 15, 15)
    put(init.attributes, initcode)
    s := initcode.code

    every j_create_field(c, 8, "v$" || !bc_undeclared_set || "$",
                       "Ljcon/vVariable;")
    every j_create_field(c, 8, !bc_op_table, "Ljcon/vDescriptor;")

    constructor := bc_init_methodref(c, "jcon/iFile")
    put(s, j_aload_0() )
    put(s, j_invokespecial(constructor) )
    put(s, j_return() )
end

procedure bc_create_class_linkinit(c)
    local clinit, clinitcode, newmethod, k, f, d, s

    clinit := j_create_method(c, 8, "<clinit>", "()V")
    clinitcode := j_create_code(c, 15, 15)
    put(clinit.attributes, clinitcode)
    s := clinitcode.code

    newmethod := bc_New_vReal_methodref(c)
    every k := key(bc_real_table) do {
        j_create_field(c, 8, bc_real_table[k], "Ljcon/vReal;")
        f := j_create_fieldref(c, bc_real_table[k], "Ljcon/vReal;",
                             bc_java_classname)
        d := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_ldc_w(d) )
        put(s, j_invokestatic(newmethod) )
        put(s, j_putstatic(f) )
    }

    every k := key(bc_integer_table) do {
        j_create_field(c, 8, bc_integer_table[k], "Ljcon/vNumeric;")
        f := j_create_fieldref(c, bc_integer_table[k], "Ljcon/vNumeric;",
                             bc_java_classname)
	if k >= (2^63) then {
            newmethod := bc_New_vBigInt_methodref(c)
            d := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
            put(s, j_ldc_w(d) )
	} else {
            newmethod := bc_New_vInteger_methodref(c)
            d := j_cp_Long(c, k)
            put(s, j_ldc2_w(d) )
	}
        put(s, j_invokestatic(newmethod) )
        put(s, j_putstatic(f) )
    }

    newmethod := bc_New_vString_methodref(c)
    every k := key(bc_string_table) do {
        j_create_field(c, 8, bc_string_table[k], "Ljcon/vString;")
        f := j_create_fieldref(c, bc_string_table[k], "Ljcon/vString;",
                             bc_java_classname)
        d := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_ldc_w(d) )
        put(s, j_invokestatic(newmethod) )
        put(s, j_putstatic(f) )
    }

    newmethod := bc_New_vCset_methodref(c)
    every k := key(bc_cset_table) do {
        j_create_field(c, 8, bc_cset_table[k], "Ljcon/vCset;")
        f := j_create_fieldref(c, bc_cset_table[k], "Ljcon/vCset;",
                             bc_java_classname)
        d := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_ldc_w(d) )
        put(s, j_invokestatic(newmethod) )
        put(s, j_putstatic(f) )
    }

    put(s, j_return() )
end
