#  irgen.icn -- translate abstract syntax trees to intermediate representation.

global ir_deferred, ir_declare_set


record ir_info(start, resume, failure, success, x)
record ir_loopinfo(nextlabel, continue, value, bounded, rval)

record ir_stacks(tmp, current_proc, createflag, declare_set, loop_stack, localSet, staticSet)


# record a_NoOp( )
procedure ir_a_NoOp(p, st, target, bounded, rval)
    local c

    ir_init(p)

    c := (ir_coord(\p.coord) | ir_coordinate("", 0, 0))
    suspend ir_chunk(p.ir.start, [ ir_Goto(c, p.ir.success) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(c, p.ir.failure) ])
end

# record a_Field( expr field )
procedure ir_a_Field(p, st, target, bounded, rval)
    local t
    ir_init(p)
    t := ir_value(p, st, target)
    suspend ir(p.expr, st, t, &null, rval)

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.expr.ir.resume) ])
    suspend ir_chunk(p.expr.ir.success, [
        ir_Field(ir_coord(p.coord), target, t, p.field.id, rval, p.expr.ir.resume),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Limitation( expr limit )
procedure ir_a_Limitation(p, st, target, bounded, rval)
    local c, t, one

    ir_init(p)
    c := ir_tmp(st)
    t := ir_tmp(st)
    one := ir_tmp(st)

    suspend ir(p.limit, st, t, &null, "rval")
    suspend ir(p.expr, st, target, bounded, rval)

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.limit.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [
        ir_opfn(ir_coord(p.coord), c, &null, ir_operator(">", 2, "rval"), [ t, c ], p.limit.ir.resume),
	ir_IntLit(ir_coord(p.coord), one, 1),
        ir_opfn(ir_coord(p.coord), c, &null, ir_operator("+", 2, "rval"), [ c, one ], p.expr.ir.resume),
        ir_Goto(ir_coord(p.coord), p.expr.ir.resume)
        ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.limit.ir.resume) ])
    suspend ir_chunk(p.limit.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.expr.ir.success, [ ir_Goto(ir_coord(p.coord), p.ir.success) ])
    suspend ir_chunk(p.limit.ir.success, [
        ir_opfn(ir_coord(p.coord), t, &null, ir_operator("#", 1, "rval"), [ t ], p.limit.ir.resume),
        ir_IntLit(ir_coord(p.coord), c, 1),
        ir_Goto(ir_coord(p.coord), p.expr.ir.start)
        ])
end

# record a_Not( expr )
procedure ir_a_Not(p, st, target, bounded, rval)
    ir_init(p)

    suspend ir(p.expr, copy(st), &null, "always bounded", "rval")

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.expr.ir.success, [
        ir_Goto(ir_coord(p.coord), p.ir.failure)
        ])
    suspend ir_chunk(p.expr.ir.failure, [
        ir_Key(ir_coord(p.coord), target, "null", &null),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
end

# record a_CoexpList( exprList )
procedure ir_a_CoexpList(p, st, target, bounded, rval)
    stop("FATAL ERROR: don't know how to do coexplist")
end

# record a_Alt( eList )
procedure ir_a_Alt(p, st, target, bounded, rval)
    local t, tmpst, i
    
    ir_init(p)
    /bounded & (t := ir_tmploc(st))

    every i := 1 to *p.eList do {
        suspend ir(p.eList[i], st, target, bounded, rval)
    }

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.eList[1].ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), t) ])

    every i := 1 to *p.eList do {
        if /bounded then {
            suspend ir_chunk(p.eList[i].ir.success, [
                ir_MoveLabel(ir_coord(p.coord), t, p.eList[i].ir.resume),
                ir_Goto(ir_coord(p.coord), p.ir.success)
                ])
        } else {
            suspend ir_chunk(p.eList[i].ir.success, [
                ir_Goto(ir_coord(p.coord), p.ir.success)
                ])
        }
        suspend ir_chunk(p.eList[i].ir.failure,[ir_Goto(ir_coord(p.coord), p.eList[i+1].ir.start)])
    }
    suspend ir_chunk(p.eList[-1].ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure)])
end

# record a_ExcAlt( eList )
procedure ir_a_ExcAlt(p, st, target, bounded, rval)
    local i, t, R, F, ch, oldt
    
    ir_init(p)
    /bounded & (R := ir_tmploc(st))
    F := ir_tmploc(st)

    every i := 1 to *p.eList do {
        suspend ir(p.eList[i], st, target, bounded, rval)
    }

    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), R) ])

    t := &null
    every i := *p.eList to 1 by -1 do {
	if /t then {
            suspend ir_chunk(p.eList[i].ir.failure,[ir_Goto(ir_coord(p.coord), p.ir.failure)])
	} else {
            suspend ir_chunk(p.eList[i].ir.failure,[ir_IndirectGoto(ir_coord(p.coord), F)])
	}

	oldt := t
        t := ir_label(p.eList[i], "prefix")
        ch := ir_chunk(t, [
            ir_MoveLabel(ir_coord(p.coord), F, \oldt | p.ir.failure),
            ir_MoveLabel(ir_coord(p.coord), R, p.eList[i].ir.resume),
            ir_Goto(ir_coord(p.coord), p.eList[i].ir.start)
	    ])
        suspend ch
        if /bounded then {
            suspend ir_chunk(p.eList[i].ir.success, [
                ir_MoveLabel(ir_coord(p.coord), F, p.ir.failure),
                ir_Goto(ir_coord(p.coord), p.ir.success)
                ])
        } else {
            suspend ir_chunk(p.eList[i].ir.success, [
                ir_Goto(ir_coord(p.coord), p.ir.success)
                ])
        }
    }
    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), t) ])  # subtle t from previous loop
end

# record a_RepAlt( expr )
procedure ir_a_RepAlt(p, st, target, bounded, rval)
    local t

    ir_init(p)
    /bounded & (t := ir_tmploc(st))
    suspend ir(p.expr, st, target, bounded, rval)

    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.expr.ir.resume) ])
    if /bounded then {
        suspend ir_chunk(p.ir.start, [
            ir_MoveLabel(ir_coord(p.coord), t, p.ir.failure),
            ir_Goto(ir_coord(p.coord), p.expr.ir.start)
            ])
        suspend ir_chunk(p.expr.ir.success, [
            ir_MoveLabel(ir_coord(p.coord), t, p.ir.start),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
        suspend ir_chunk(p.expr.ir.failure, [ ir_IndirectGoto(ir_coord(p.coord), t) ])
    } else {
        suspend ir_chunk(p.ir.start, [
            ir_Goto(ir_coord(p.coord), p.expr.ir.start)
            ])
        suspend ir_chunk(p.expr.ir.success, [
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
        suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    }
end

# record a_Case( expr clauseList dflt )
procedure ir_a_Case(p, st, target, bounded, rval)
    local t, L, i, e, v, x
    local oiu

    /p.dflt := a_Key("fail", p.coord)

    ir_init(p)
    /bounded & (t := ir_tmploc(st))
    e := ir_tmp(st)
    v := (\target | ir_tmp(st))

    suspend ir(p.expr, st, e, "always bounded", "rval")

    every i := 1 to *p.clauseList do {
        suspend ir(p.clauseList[i].expr, st, v, &null, "rval")
        suspend ir(p.clauseList[i].body, st, target, bounded, rval)
    }
    suspend ir(p.dflt, st, target, bounded, rval)

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), t) ])

    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])

    L := p.clauseList
    if *L = 0 then {
        suspend ir_chunk(p.expr.ir.success, [ ir_Goto(ir_coord(p.coord), p.dflt.ir.start) ])
    } else {
        suspend ir_chunk(p.expr.ir.success, [ ir_Goto(ir_coord(p.coord), L[1].expr.ir.start) ])
        every i := 1 to *L do {
            suspend ir_chunk(L[i].expr.ir.success, [
                ir_opfn(ir_coord(p.coord), &null, &null, ir_operator("===", 2, "rval"), [ e, v ],
                        L[i].expr.ir.resume),
                ir_Goto(ir_coord(p.coord), L[i].body.ir.start)
                ])
            suspend ir_chunk(L[i].expr.ir.failure,
                             [ ir_Goto(ir_coord(p.coord), L[i+1].expr.ir.start) ])
            if /bounded then {
                suspend ir_chunk(L[i].body.ir.success, [
                    ir_MoveLabel(ir_coord(p.coord), t, L[i].body.ir.resume),
                    ir_Goto(ir_coord(p.coord), p.ir.success)
                    ])
            } else {
                suspend ir_chunk(L[i].body.ir.success, [
                    ir_Goto(ir_coord(p.coord), p.ir.success)
                    ])
            }
            suspend ir_chunk(L[i].body.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
        }
        suspend ir_chunk(L[-1].expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.dflt.ir.start) ])
    }

    if /bounded then {
        suspend ir_chunk(p.dflt.ir.success, [
            ir_MoveLabel(ir_coord(p.coord), t, p.dflt.ir.resume),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
    } else {
        suspend ir_chunk(p.dflt.ir.success, [
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
    }
    suspend ir_chunk(p.dflt.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Every( expr body )
procedure ir_a_Every(p, st, target, bounded, rval)
    local tmp

    /p.body := a_Key("fail", p.coord)

    ir_init_loop(p, st, target, bounded, rval)
    put(st.loop_stack, p)
    tmp := copy(st)
    suspend ir(p.expr, tmp, &null, &null, "rval")
    suspend ir(p.body, tmp, &null, "always bounded", "rval")
    pull(st.loop_stack)

    suspend ir_chunk(p.ir.x.nextlabel, [ ir_Goto(ir_coord(p.coord), p.expr.ir.resume) ])
    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), p.ir.x.continue) ])
    suspend ir_chunk(p.expr.ir.success, [ ir_Goto(ir_coord(p.coord), p.body.ir.start) ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.body.ir.success, [
        ir_Goto(ir_coord(p.coord), p.expr.ir.resume)
        ])
    suspend ir_chunk(p.body.ir.failure, [ ir_Goto(ir_coord(p.coord), p.expr.ir.resume) ])
end

# record a_Sectionop( op val left right )
procedure ir_a_Sectionop(p, st, target, bounded, rval)
    local vv, lv, rv

    ir_init(p)
    vv := ir_value(p.val, st, &null)
    lv := ir_value(p.left, st, &null)
    rv := ir_value(p.right, st, target)

    suspend ir(p.val, st, vv, &null, rval)
    suspend ir(p.left, st, lv, &null, "rval")
    suspend ir(p.right, st, rv, &null, "rval")

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.val.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.right.ir.resume) ])
    suspend ir_chunk(p.val.ir.success, [ ir_Goto(ir_coord(p.coord), p.left.ir.start) ])
    suspend ir_chunk(p.val.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.left.ir.success, [ ir_Goto(ir_coord(p.coord), p.right.ir.start) ])
    suspend ir_chunk(p.left.ir.failure, [ ir_Goto(ir_coord(p.coord), p.val.ir.resume) ])
    suspend ir_chunk(p.right.ir.success, [
        ir_opfn(ir_coord(p.coord), target, &null, ir_operator(p.op, 3, rval), [ vv, lv, rv], p.right.ir.resume),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    suspend ir_chunk(p.right.ir.failure, [ ir_Goto(ir_coord(p.coord), p.left.ir.resume) ])
end

# record a_Call( fn args )
procedure ir_a_Call(p, st, target, bounded, rval)
    local value, L, i, fn, args, clsr

    \p.coord | runerr(500, p)
    every /(!p.args.exprList) := a_Key("null", p.coord)
    if type(p.args) == "a_CoexpList" then {
        L := []
        every put(L, a_Create(!p.args.exprList, p.coord))
        p.args := a_Arglist([a_ListConstructor(L, p.coord)])
    }

    ir_init(p)
    value := ir_tmp(st)
    clsr := ir_tmpclosure(st)
    fn := ir_tmp(st)
    args := []
    every i := !p.args.exprList do put(args, ir_value(i, st, &null))

    suspend ir(p.fn, st, fn, &null, "rval")
    every i := 1 to *p.args.exprList do {
        suspend ir(p.args.exprList[i], st, args[i], &null,
		   if type(p.args.exprList[i]) == "a_Ident"
		   then "rval" else &null)
    }

    L := [p.fn] ||| p.args.exprList
    \p.coord | runerr(500, p)

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.fn.ir.start) ])
    suspend ir_chunk(p.ir.resume, [
        ir_ResumeValue(ir_coord(p.coord), target, clsr, clsr, L[-1].ir.resume),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    every i := 1 to *L do {
        suspend ir_chunk(L[i].ir.success, [ ir_Goto(ir_coord(p.coord), L[i+1].ir.start) ])
        suspend ir_chunk(L[i].ir.failure, [ ir_Goto(ir_coord(p.coord), L[i-1].ir.resume) ])
    }
    suspend ir_chunk(L[ 1].ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(L[-1].ir.success, [
	# ir_Deref(ir_coord(p.coord), fn, fn), #%#%# is this necessary?
        ir_Call(ir_coord(p.coord), value, clsr, fn, args, L[-1].ir.resume),
        ir_Move(ir_coord(p.coord), target, value),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
end

procedure ir_conjunction(p, st, target, bounded, rval)
    ir_init(p)
    suspend ir(p.left, st, &null, &null, "rval")
    suspend ir(p.right, st, target, bounded, rval)
    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.left.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.right.ir.resume) ])
    suspend ir_chunk(p.left.ir.success, [ ir_Goto(ir_coord(p.coord), p.right.ir.start) ])
    suspend ir_chunk(p.left.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.right.ir.success, [ ir_Goto(ir_coord(p.coord), p.ir.success) ])
    suspend ir_chunk(p.right.ir.failure, [ ir_Goto(ir_coord(p.coord), p.left.ir.resume) ])
end

procedure ir_augmented_assignment(p, target, bounded, rval, lv, rv, tmp)
    local op

    op := (p.op ? tab(find(":=")))
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.right.ir.resume) ])
    suspend ir_chunk(p.right.ir.success, [
        ir_opfn(ir_coord(p.coord), tmp, &null, ir_operator(op, 2, "rval"), [ lv, rv ], p.right.ir.resume),
        ir_opfn(ir_coord(p.coord), target, &null, ir_operator(":=", 2, rval), [ lv, tmp ],
                p.right.ir.resume),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
end

procedure ir_binary(p, target, bounded, rval, lv, rv, clsr, funcs)
    local args

    if p.op == "@" then {
        args := [ rv, lv ]
    } else {
        args := [ lv, rv ]
    }
    if member(funcs, p.op) then {
        /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.right.ir.resume) ])
        suspend ir_chunk(p.right.ir.success, [
            ir_opfn(ir_coord(p.coord), target, &null, ir_operator(p.op, 2, rval), args,
                    p.right.ir.resume),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
    } else {
        suspend ir_chunk(p.ir.resume, [
            ir_ResumeValue(ir_coord(p.coord), target, clsr, clsr, p.right.ir.resume),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
        suspend ir_chunk(p.right.ir.success, [
            ir_opfn(ir_coord(p.coord), target, clsr, ir_operator(p.op, 2, rval), args,
                    p.right.ir.resume),
            # ir_Move(ir_coord(p.coord), target, clsr),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
    }
end

procedure ir_rval(op, arity, arg, parent)
    if find(":=", op) & arg = 1 then return &null
    else if op == "<-" & arg = 1 then return &null
    else if op == (":=:" | "<->") then return &null
    else if op == "[]" & arg = 1 then return parent
    else if op == "!" & arity = 1 then return parent
    else if op == "?" & arity = 1 then return parent
    else if op == "/" & arity = 1 then return parent
    else if op == "\\" & arity = 1 then return parent
    else return "rval"
end

# record a_Binop( op left right )
procedure ir_a_Binop(p, st, target, bounded, rval)
    local clsr, tmp, op, lv, rv
    static funcs    # functions for which resumption fails immediately.
    initial {
        funcs := set([ ":=", ":=:", "&", ".", "[]", "+", "-", "/",
            "*", "%", "^", "**", "++", "--", "<", "<=", "=", "~=",
            ">=", ">", "<<", "<<=", "==", "~==", ">>=", ">=", ">>",
            "===", "~===", "|||", "||", "@" ])
    }

    /p.right := a_Key("null", p.coord)

    if p.op == "&" then {
        suspend ir_conjunction(p, st, target, bounded, rval)
        fail
    }

    ir_init(p)
    if not member(funcs, p.op) &
       not member(funcs, p.op[1:find(":=", p.op)]) then {
        clsr := ir_tmpclosure(st)
    }
    lv := ir_value(p.left, st, &null)
    rv := ir_value(p.right, st, target)
    tmp := (\target | ir_tmp(st))

    suspend ir(p.left,  st, lv, &null, ir_rval(p.op, 2, 1, rval))
    suspend ir(p.right, st, rv, &null, ir_rval(p.op, 2, 2, rval))

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.left.ir.start) ])
    suspend ir_chunk(p.left.ir.success, [ ir_Goto(ir_coord(p.coord), p.right.ir.start) ])
    suspend ir_chunk(p.left.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.right.ir.failure, [ ir_Goto(ir_coord(p.coord), p.left.ir.resume) ])

    if find(":=", p.op) > 1 then {
        suspend ir_augmented_assignment(p, target, bounded, rval, lv, rv, tmp)
    } else {
        suspend ir_binary(p, target, bounded, rval, lv, rv, clsr, funcs)
    }
end

procedure ir_unary_coexp(p, st, target, bounded, rval)
    local t

    t := a_Binop("@", a_Key("null", p.coord), p.operand, ir_coord(p.coord))
    suspend ir(t, st, target, bounded, rval)
    p.ir := t.ir
end

procedure ir_unary(p, target, bounded, rval, v, clsr, funcs)
    if member(funcs, p.op) then {
        /bounded & suspend ir_chunk(p.ir.resume, [ir_Goto(ir_coord(p.coord), p.operand.ir.resume)])
        suspend ir_chunk(p.operand.ir.success, [
            ir_opfn(ir_coord(p.coord), target, &null, ir_operator(p.op, 1, rval), [ v ], p.operand.ir.resume),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
    } else {
        suspend ir_chunk(p.ir.resume, [
            ir_ResumeValue(ir_coord(p.coord), target, clsr, clsr, p.operand.ir.resume),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
        suspend ir_chunk(p.operand.ir.success, [
            ir_opfn(ir_coord(p.coord), target, clsr, ir_operator(p.op, 1, rval), [ v ], p.operand.ir.resume),
            # ir_Move(ir_coord(p.coord), target, closure),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
    }
end

# record a_Unop( op operand )
procedure ir_a_Unop(p, st, target, bounded, rval)
    local closure, v, t
    static funcs    # functions for which resumption fails immediately.
    initial {
        funcs := set([ ".", "/", "\\", "*", "?", "+", "-", "~", "^" ])
    }

    if p.op == "@" then {
        suspend ir_unary_coexp(p, st, target, bounded, rval)
        fail
    }

    ir_init(p)
    if not member(funcs, p.op) then {
        closure := ir_tmpclosure(st)
    }
    v := ir_value(p.operand, st, target)

    suspend ir(p.operand, st, v, &null, ir_rval(p.op, 1, 1, rval))

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.operand.ir.start) ])
    suspend ir_unary(p, target, bounded, rval, v, closure, funcs)
    suspend ir_chunk(p.operand.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Global( idList )
procedure ir_a_Global(p, st, target, bounded, rval)
    local globals

    globals := []
    every put(globals, (!p.idList).id)
    return ir_Global(ir_coord(p.coord), globals)
end

# record a_If( expr thenexpr elseexpr )
procedure ir_a_If(p, st, target, bounded, rval)
    local t

    /p.elseexpr := a_Key("fail", p.coord)

    ir_init(p)
    /bounded & (t := ir_tmploc(st))

    suspend ir(p.expr, copy(st), &null, "always bounded", "rval")
    suspend ir(p.thenexpr, st, target, bounded, rval)
    suspend ir(p.elseexpr, st, target, bounded, rval)

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), t) ])
    if /bounded then {
        suspend ir_chunk(p.expr.ir.success, [
            ir_MoveLabel(ir_coord(p.coord), t, p.thenexpr.ir.resume),
            ir_Goto(ir_coord(p.coord), p.thenexpr.ir.start)
            ])
        suspend ir_chunk(p.expr.ir.failure, [
            ir_MoveLabel(ir_coord(p.coord), t, p.elseexpr.ir.resume),
            ir_Goto(ir_coord(p.coord), p.elseexpr.ir.start)
            ])
    } else {
        suspend ir_chunk(p.expr.ir.success, [
            ir_Goto(ir_coord(p.coord), p.thenexpr.ir.start)
            ])
        suspend ir_chunk(p.expr.ir.failure, [
            ir_Goto(ir_coord(p.coord), p.elseexpr.ir.start)
            ])
    }
    suspend ir_chunk(p.thenexpr.ir.success, [ ir_Goto(ir_coord(p.coord), p.ir.success) ])
    suspend ir_chunk(p.thenexpr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.elseexpr.ir.success, [ ir_Goto(ir_coord(p.coord), p.ir.success) ])
    suspend ir_chunk(p.elseexpr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Initial( expr )
procedure ir_a_Initial(p, st, target, bounded, rval)
    /p.expr := a_NoOp()

    st.loop_stack := []

    ir_init(p)
    suspend ir(p.expr, st, target, "always bounded", "rval")

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Unreachable(ir_coord(p.coord)) ])
    suspend ir_chunk(p.expr.ir.success, [
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.success) ])
end

# record a_Invocable( invocList )
procedure ir_a_Invocable(p, st, target, bounded, rval)
    local all, inv, i

    inv := []
    every i := !p.invocList do {
        case type(i) of {
        "a_Ident" : {
            if i.id == "all" then {
                all := 1
            }
            }
        "a_Stringlit" : {
            put(inv, i.str)
            }
        }
    }
    return ir_Invocable(ir_coord(p.coord), inv, all)
end

# record a_Link( linkfileList )
procedure ir_a_Link(p, st, target, bounded, rval)
    return ir_Link(ir_coord(p.coord), p.linkfileList)
end

procedure ir_value(p, st, target)
    return ( \target | ir_tmp(st))
end

# record a_Intlit( int )
procedure ir_a_Intlit(p, st, target, bounded, rval)

    if type(target) == "ir_IntLit" then target := &null

    ir_init(p)

    if not (p.int := integer(p.int)) then {
        semantic_error(p.int || ": illegal integer literal", ir_coord(p.coord))
    }
    suspend ir_chunk(p.ir.start, [
        ir_IntLit(ir_coord(p.coord), target, p.int),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Reallit( real )
procedure ir_a_Reallit(p, st, target, bounded, rval)

    if type(target) == "ir_RealLit" then target := &null

    ir_init(p)

    if not (p.real := real(p.real)) then {
        semantic_error(p.real || ": illegal real literal", ir_coord(p.coord))
    }
    suspend ir_chunk(p.ir.start, [
        ir_RealLit(ir_coord(p.coord), target, p.real),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Stringlit( str )
procedure ir_a_Stringlit(p, st, target, bounded, rval)

    if type(target) == "ir_StrLit" then target := &null

    ir_init(p)

    suspend ir_chunk(p.ir.start, [
        ir_StrLit(ir_coord(p.coord), target, *p.str, p.str),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Csetlit( str )
procedure ir_a_Csetlit(p, st, target, bounded, rval)

    if type(target) == "ir_CsetLit" then target := &null

    ir_init(p)

    suspend ir_chunk(p.ir.start, [
        ir_CsetLit(ir_coord(p.coord), target, *p.str, p.str),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

procedure ir_nested(p, st, target, bounded, rval)
end

# record a_ProcDecl( ident paramList accumulate localsList code )
procedure ir_a_ProcDeclNested(p, st, target, bounded, rval)
    local f
    static counter

    initial {
	counter := 0
    }
    counter +:= 1

    ir_init(p)

    if type(target) == "ir_ProcDecl" then target := &null

    p.ident.id := st.current_proc || "$nested$" || counter

    suspend ir_chunk(p.ir.start, [
        ir_MakeClosure(ir_coord(p.coord), target, p.ident.id),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])

    st := ir_stacks(0)
    f := ir_a_ProcDecl0(p, st)
    push(ir_deferred, f)
end

# record a_ProcDecl( ident paramList accumulate localsList code )
procedure ir_a_ProcDecl(p, st, target, bounded, rval)
    st := ir_stacks(0)
    suspend ir_a_ProcDecl0(p, st)
end

procedure ir_a_ProcDecl0(p, st, target, bounded, rval)
    local locals, statics, params, i, v, code

    st.localSet := set([])
    st.staticSet := set([])
    st.current_proc := p.ident.id

    v := set([])
    every i := !p.paramList do {
        if member(v, i.id) then {
            semantic_error(image(i.id) || ": redeclared identifier", i.coord)
        }
        insert(v, i.id)
    }
    if member(ir_declare_set, p.ident.id) then {
	semantic_error(image(name) || ": inconsistent redeclaration",
		       p.ident.coord)
    }
    insert(ir_declare_set, p.ident.id)

    params := []
    every put(params, (!p.paramList).id)

    code := []
    every put(code, ir(p.code, st))

    locals := []
    every put(locals, !st.localSet)
    statics := []
    every put(statics, !st.staticSet)

    return ir_Function(ir_coord(p.ident.coord), p.ident.id, params,
		      p.accumulate, locals, statics, code,
                      p.code.ir.start)
end

# record a_ProcBody( nexprList )
procedure ir_a_ProcBody(p, st, target, bounded, rval)
    local L, i

    every /(!p.nexprList) := a_Key("null", p.coord)


    st.loop_stack := []

    ir_init(p)

    L := ir_make_sentinel(p.nexprList)
    every i := 1 to *p.nexprList do {
        suspend ir(p.nexprList[i], st, &null, "always bounded", "rval")
    }

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), L[1].ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Unreachable(ir_coord(p.coord)) ])
    every i := 1 to *L-1 do {
        suspend ir_chunk(L[i].ir.success, [
            ir_Goto(ir_coord(p.coord), L[i+1].ir.start)
            ])
        suspend ir_chunk(L[i].ir.failure, [ ir_Goto(ir_coord(p.coord), L[i+1].ir.start) ])
    }
    suspend ir_chunk(L[-1].ir.success, [
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    suspend ir_chunk(L[-1].ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_ProcCode( body )
procedure ir_a_ProcCode(p, st, target, bounded, rval)
    ir_init(p)

    st.loop_stack := []

    suspend ir(p.body, st, &null, "always bounded", "rval")

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.body.ir.start) ])
    suspend ir_chunk(p.ir.resume, [ ir_Unreachable(ir_coord(p.coord)) ])
    suspend ir_chunk(p.body.ir.success, [ ir_Fail(ir_coord(p.coord)) ])
    suspend ir_chunk(p.body.ir.failure, [ ir_Fail(ir_coord(p.coord)) ])
end

# record a_Record( ident idlist )
procedure ir_a_Record(p, st, target, bounded, rval)
    local fields, v, i

    if member(ir_declare_set, p.ident.id) then {
	semantic_error(image(name) || ": inconsistent redeclaration",
		       p.ident.coord)
    }
    insert(ir_declare_set, p.ident.id)
    v := set([])
    every i := !p.idlist do {
        if member(v, i.id) then {
            semantic_error(image(i.id) || ": redeclared identifier", i.coord)
        }
        insert(v, i.id)
    }
    fields := []
    every put(fields, (!p.idlist).id)
    return ir_Record(ir_coord(p.ident.coord), p.ident.id, fields)
end

# record a_Repeat( expr )
procedure ir_a_Repeat(p, st, target, bounded, rval)
    ir_init_loop(p, st, target, bounded, rval)
    put(st.loop_stack, p)
    suspend ir(p.expr, copy(st), &null, "always bounded", "rval")
    pull(st.loop_stack)

    suspend ir_chunk(p.ir.x.nextlabel, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), p.ir.x.continue) ])
    suspend ir_chunk(p.expr.ir.success, [
        ir_Goto(ir_coord(p.coord), p.ir.start)
        ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.start) ])
end

# record a_Return( expr )
procedure ir_a_Return(p, st, target, bounded, rval)
    local t, mk

    /st.createflag |semantic_error("invalid context for return or fail",p.coord)

    /p.expr := a_Key("null", p.coord)

    ir_init(p)
    t := ir_tmp(st)
    mk := ir_tmp(st)

    suspend ir(p.expr, copy(st), t, "always bounded", &null)

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Fail(ir_coord(p.coord)) ])
        suspend ir_chunk(p.expr.ir.success, [
            ir_Succeed(ir_coord(p.coord), t, &null)
            ])
        suspend ir_chunk(p.expr.ir.failure, [ ir_Fail(ir_coord(p.coord)) ])
end

# record a_Fail( )
procedure ir_a_Fail(p, st, target, bounded, rval)
    local mk

    /st.createflag |semantic_error("invalid context for return or fail",p.coord)

    ir_init(p)

        suspend ir_chunk(p.ir.start, [ ir_Fail(ir_coord(p.coord)) ])
        /bounded & suspend ir_chunk(p.ir.resume, [ ir_Fail(ir_coord(p.coord)) ])
end

# record a_Suspend( expr body )
procedure ir_a_Suspend(p, st, target, bounded, rval)
    local t, tmp, susp

    /st.createflag | semantic_error("invalid context for suspend", p.coord)

    /p.body := a_Key("fail", p.coord) & /p.expr := a_Key("null", p.coord)

    ir_init_loop(p, st, target, bounded, rval)
    t := ir_label(p, "suspend")
    susp := ir_tmp(st)

    put(st.loop_stack, p)
    tmp := copy(st)
    suspend ir(p.expr, tmp, susp, &null, "rval")
    suspend ir(p.body, tmp, &null, "always bounded", &null)
    pull(st.loop_stack)

    suspend ir_chunk(p.ir.x.nextlabel, [ ir_Goto(ir_coord(p.coord), p.expr.ir.resume) ])
    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), p.ir.x.continue) ])
        suspend ir_chunk(p.expr.ir.success, [ ir_Succeed(ir_coord(p.coord), susp, t) ])
        suspend ir_chunk(t, [ ir_Goto(ir_coord(p.coord), p.body.ir.start) ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.body.ir.success, [
        ir_Goto(ir_coord(p.coord), p.expr.ir.resume)
        ])
    suspend ir_chunk(p.body.ir.failure, [ ir_Goto(ir_coord(p.coord), p.expr.ir.resume) ])
end

# record a_Until( expr body )
procedure ir_a_Until(p, st, target, bounded, rval)
    /p.body := a_Key("fail", p.coord)

    ir_init_loop(p, st, target, bounded, rval)
    put(st.loop_stack, p)
    suspend ir(p.expr, copy(st), &null, "always bounded", "rval")
    suspend ir(p.body, copy(st), &null, "always bounded", "rval")
    pull(st.loop_stack)

    suspend ir_chunk(p.ir.x.nextlabel, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), p.ir.x.continue) ])
    suspend ir_chunk(p.expr.ir.success, [
        ir_Goto(ir_coord(p.coord), p.ir.failure)
        ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.body.ir.start) ])
    suspend ir_chunk(p.body.ir.success, [
        ir_Goto(ir_coord(p.coord), p.expr.ir.start)
        ])
    suspend ir_chunk(p.body.ir.failure, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
end

# record a_While( expr body )
procedure ir_a_While(p, st, target, bounded, rval)
    /p.body := a_Key("fail", p.coord)

    ir_init_loop(p, st, target, bounded, rval)
    put(st.loop_stack, p)
    suspend ir(p.expr, copy(st), &null, "always bounded", "rval")
    suspend ir(p.body, copy(st), &null, "always bounded", "rval")
    pull(st.loop_stack)

    suspend ir_chunk(p.ir.x.nextlabel, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), p.ir.x.continue) ])
    suspend ir_chunk(p.expr.ir.success, [
        ir_Goto(ir_coord(p.coord), p.body.ir.start)
        ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.body.ir.success, [
        ir_Goto(ir_coord(p.coord), p.expr.ir.start)
        ])
    suspend ir_chunk(p.body.ir.failure, [ ir_Goto(ir_coord(p.coord), p.expr.ir.start) ])
end

# record a_Create( expr )
procedure ir_a_Create(p, st, target, bounded, rval)
    local t

    \p.coord | runerr(500, p)
    ir_init(p)
    t := (\target | ir_tmp(st))

    st.createflag := 1
    suspend ir(p.expr, st, t, &null, &null)
    st.createflag := &null

    suspend ir_chunk(p.ir.start, [
        ir_Create(ir_coord(p.coord), target, p.expr.ir.start),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.expr.ir.success, [ ir_CoRet(ir_coord(p.coord), t, p.expr.ir.resume) ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_CoFail(ir_coord(p.coord)) ])
end


# record a_Local( id )
procedure ir_a_Local(p, st, target, bounded, rval)
    insert(st.localSet, p.id) # should check for collisions
    suspend ir_a_Ident(p, st, target, bounded, rval)
end

# record a_Static( id )
procedure ir_a_Static(p, st, target, bounded, rval)
    insert(st.staticSet, p.id) # should check for collisions
    suspend ir_a_Ident(p, st, target, bounded, rval)
end

# record a_Ident( id )
procedure ir_a_Ident(p, st, target, bounded, rval)
    if type(\target) ~== "ir_Tmp" then {
        # #%#%# prevents nasty interaction with targeting.
        # %#%#% probably a symptom of bad design....
        target := &null
    }

    ir_init(p)

    suspend ir_chunk(p.ir.start, [
        ir_Var(ir_coord(p.coord), target, p.id),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Next( )
procedure ir_a_Next(p, st, target, bounded, rval)
    local curloop, sl, mk

    st.loop_stack[1] | semantic_error("invalid context for next", p.coord)

    ir_init(p)

    curloop := st.loop_stack[-1]
        suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), curloop.ir.x.nextlabel) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Unreachable(ir_coord(p.coord)) ])
end

# record a_Break( expr )
procedure ir_a_Break(p, st, target, bounded, rval)
    local curloop, oldloops, clx, mk

    st.loop_stack[1] | semantic_error("invalid context for break", p.coord)

    /p.expr := a_Key("null", p.coord)

    ir_init(p)

    curloop := st.loop_stack[-1] 
    oldloops := st.loop_stack
    st.loop_stack := st.loop_stack[1:-1] 
    clx := curloop.ir.x
    suspend ir(p.expr, st, clx.value, clx.bounded, clx.rval)
    st.loop_stack := oldloops

        if /clx.bounded then {
            suspend ir_chunk(p.ir.start, [
                ir_MoveLabel(ir_coord(p.coord), clx.continue, p.ir.resume),
                ir_Goto(ir_coord(p.coord), p.expr.ir.start)
                ])
        } else {
            suspend ir_chunk(p.ir.start, [
                ir_Goto(ir_coord(p.coord), p.expr.ir.start)
                ])
        }
    /clx.bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.expr.ir.resume) ])
    suspend ir_chunk(p.expr.ir.success, [ ir_Goto(ir_coord(p.coord), curloop.ir.success) ])
    suspend ir_chunk(p.expr.ir.failure, [ ir_Goto(ir_coord(p.coord), curloop.ir.failure) ])
end

# record a_ToBy( fromexpr toexpr byexpr )
procedure ir_a_ToBy(p, st, target, bounded, rval)
    local clsr, fv, tv, bv

    /p.byexpr := a_Intlit(1, p.coord)

    ir_init(p)
    clsr := ir_tmpclosure(st)
    fv := ir_value(p.fromexpr, st, &null)
    tv := ir_value(p.toexpr, st, &null)
    bv := ir_value(p.byexpr, st, target)

    suspend ir(p.fromexpr, st, fv, &null, "rval")
    suspend ir(p.toexpr, st, tv, &null, "rval")
    suspend ir(p.byexpr, st, bv, &null, "rval")

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.fromexpr.ir.start) ])
    suspend ir_chunk(p.ir.resume, [
        ir_ResumeValue(ir_coord(p.coord), target, clsr, clsr, p.byexpr.ir.resume),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    suspend ir_chunk(p.fromexpr.ir.success, [ ir_Goto(ir_coord(p.coord), p.toexpr.ir.start) ])
    suspend ir_chunk(p.fromexpr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.toexpr.ir.success, [ ir_Goto(ir_coord(p.coord), p.byexpr.ir.start) ])
    suspend ir_chunk(p.toexpr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.fromexpr.ir.resume) ])
    suspend ir_chunk(p.byexpr.ir.success, [
        ir_opfn(ir_coord(p.coord), target, clsr, ir_operator("...", 3, "rval"), [ fv, tv, bv ], p.byexpr.ir.resume),
        # ir_Move(ir_coord(p.coord), target, closure),
        ir_Goto(ir_coord(p.coord), p.ir.success)
        ])
    suspend ir_chunk(p.byexpr.ir.failure, [ ir_Goto(ir_coord(p.coord), p.toexpr.ir.resume) ])

end

# record a_Select( caseList, dflt )
procedure ir_a_Select(p, st, target, bounded, rval)
    local i, left, right, caseList, sc, c, t, select, lab, dest

    ir_init(p)

    /bounded & (t := ir_tmploc(st))
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_IndirectGoto(ir_coord(p.coord), t) ])

    select := ir_label(p, "select")

    caseList := []
    every i := *p.caseList to 1 by -1 do {
        c := p.caseList[i]
        suspend ir(c.body, st, target, bounded, rval)
        suspend ir_chunk(c.body.ir.failure, [ ir_Goto(ir_coord(c.coord), p.ir.failure) ])
        suspend ir_chunk(c.body.ir.success, [ ir_Goto(ir_coord(c.coord), p.ir.success) ])
        if /bounded then {
            lab := ir_label(c, "setup")
            suspend ir_chunk(lab, [
                ir_MoveLabel(ir_coord(c.coord), t, c.body.ir.resume),
                ir_Goto(ir_coord(c.coord), c.body.ir.start)
                ])
        } else {
            lab := c.body.ir.start
        }

        left := ir_tmp(st)
        right := ir_tmp(st)
        sc := ir_SelectCase(ir_coord(c.coord), c.kind, left, right, lab)
        put(caseList, sc)
        suspend ir(c.left, st, left, &null, &null)
        suspend ir(c.right, st, right, "bounded", "rval")
        suspend ir_chunk(c.left.ir.success, [ ir_Goto(ir_coord(c.coord), c.right.ir.start) ])
        dest := p.caseList[i+1].left.ir.start | select
        suspend ir_chunk(c.left.ir.failure, [
            ir_NoValue(ir_coord(c.coord), left),
            ir_Goto(ir_coord(c.coord), dest)
            ])
        dest := p.caseList[i+1].left.ir.start | select
        suspend ir_chunk(c.right.ir.success, [ ir_Goto(ir_coord(c.coord), dest) ])
        suspend ir_chunk(c.right.ir.failure, [ ir_Goto(ir_coord(c.coord), c.left.ir.resume) ])
    }
    if c := \p.dflt then {
        suspend ir(c.body, st, target, bounded, rval)
        suspend ir_chunk(c.body.ir.failure, [ ir_Goto(ir_coord(c.coord), p.ir.failure) ])
        suspend ir_chunk(c.body.ir.success, [ ir_Goto(ir_coord(c.coord), p.ir.success) ])
        if /bounded then {
            lab := ir_label(c, "setup")
            suspend ir_chunk(lab, [
                ir_MoveLabel(ir_coord(c.coord), t, c.body.ir.resume),
                ir_Goto(ir_coord(c.coord), c.body.ir.start)
                ])
        } else {
            lab := c.body.ir.start
        }
        sc := ir_SelectCase(ir_coord(c.coord), "default", &null, &null, c.body.ir.start)
        put(caseList, sc)
    }

    suspend ir_chunk(select, [ ir_Select(ir_coord(p.coord), caseList) ])

    if p.caseList[1] then {
        suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.caseList[1].left.ir.start) ])
    } else {
        suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), select) ])
    }
end

# record a_Mutual( exprList )
procedure ir_a_Mutual(p, st, target, bounded, rval)
    local L, i

    if *p.exprList = 0 then {
        p.exprList := [ a_Key("null", p.coord) ]
    } else {
        every /(!p.exprList) := a_Key("null", p.coord)
    }

    ir_init(p)

    every i := 1 to *p.exprList-1 do {
        suspend ir(p.exprList[i], st, &null, &null, "rval")
    }
    suspend ir(p.exprList[-1], st, target, bounded, rval)
    L := p.exprList

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), L[1].ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), L[-1].ir.resume) ])

    every i := 1 to *L do {
        suspend ir_chunk(L[i].ir.success, [ ir_Goto(ir_coord(p.coord), L[i+1].ir.start) ])
        suspend ir_chunk(L[i].ir.failure, [ ir_Goto(ir_coord(p.coord), L[i-1].ir.resume) ])
    }
    suspend ir_chunk(L[-1].ir.success, [ ir_Goto(ir_coord(p.coord), p.ir.success) ])
    suspend ir_chunk(L[ 1].ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
end

# record a_Compound( exprList )
procedure ir_a_Compound(p, st, target, bounded, rval)
    local L, i

    every /(!p.exprList) := a_Key("null", p.coord)

    ir_init(p)

    every i := 1 to *p.exprList-1 do {
        suspend ir(p.exprList[i], copy(st), &null, "always bounded", "rval")
    }
    suspend ir(p.exprList[-1], st, target, bounded, rval)

    L := p.exprList
    *L > 0 | stop("fatal error in ir_a_Compound")
    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), L[1].ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), L[-1].ir.resume) ])

    every i := 1 to *p.exprList-1 do {
        suspend ir_chunk(L[i].ir.success, [
            ir_Goto(ir_coord(p.coord), L[i+1].ir.start)
            ])
        suspend ir_chunk(L[i].ir.failure, [ ir_Goto(ir_coord(p.coord), L[i+1].ir.start) ])
    }
    suspend ir_chunk(L[-1].ir.success, [ ir_Goto(ir_coord(p.coord), p.ir.success) ])
    suspend ir_chunk(L[-1].ir.failure, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])

end

# record a_Key( id )
procedure ir_a_Key(p, st, target, bounded, rval)
    local closure

    ir_init(p)
    \p.coord | runerr(500, p)

    case (p.id) of {
    "line" : {
	suspend ir_chunk(p.ir.start, [
	    ir_IntLit(ir_coord(p.coord), target, p.coord.line),
	    ir_Goto(ir_coord(p.coord), p.ir.success)
	    ])
	suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    }
    "file" : {
	suspend ir_chunk(p.ir.start, [
	    ir_StrLit(ir_coord(p.coord), target, *p.coord.file, p.coord.file),
	    ir_Goto(ir_coord(p.coord), p.ir.success)
	    ])
	suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    }
    "fail" : {
	suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
        /bounded & suspend ir_chunk(p.ir.resume, [ ir_Unreachable(ir_coord(p.coord)) ])
    }
    default : {
        closure := ir_tmp(st)
        suspend ir_chunk(p.ir.start, [
            ir_Key(ir_coord(p.coord), closure, ir_key(p.id), p.ir.failure),
            ir_Move(ir_coord(p.coord), target, closure),
            ir_Goto(ir_coord(p.coord), p.ir.success)
	    ])
	if key_generator(p.id) then {
            suspend ir_chunk(p.ir.resume, [
                ir_ResumeValue(ir_coord(p.coord), target, closure, p.ir.failure),
                ir_Goto(ir_coord(p.coord), p.ir.success)
                ])
	} else {
            suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
	}
    }
    }
end

# record a_Arglist( exprList )
procedure ir_a_Arglist(p, st, target, bounded, rval)
    stop("FATAL ERROR: a_Arglist should be handled in ir_a_Call(), file ",
         image(&file), ", line ", image(&line))
end

# record a_ListConstructor( exprList )
procedure ir_a_ListConstructor(p, st, target, bounded, rval)
    local L, i, args

    \p.coord | runerr(500, p)
    every /(!p.exprList) := a_Key("null", p.coord)

    ir_init(p)

    args := []
    if \target then {
        every i := !p.exprList do put(args, ir_value(i, st, &null))
    } else {
        every !p.exprList do put(args, &null)
    }

    every i := 1 to *p.exprList do {
        suspend ir(p.exprList[i], st, args[i], &null, "rval")
    }

    L := ir_make_sentinel(p.exprList)

    suspend ir_chunk(p.ir.start, [ ir_Goto(ir_coord(p.coord), L[1].ir.start) ])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), L[-1].ir.resume) ])

    suspend ir_chunk(L[1].ir.start, [ ir_Goto(ir_coord(p.coord), L[2].ir.start) ])
    suspend ir_chunk(L[1].ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    every i := 2 to *p.exprList-1 do {
        suspend ir_chunk(L[i].ir.success, [ ir_Goto(ir_coord(p.coord), L[i+1].ir.start) ])
        suspend ir_chunk(L[i].ir.failure, [ ir_Goto(ir_coord(p.coord), L[i-1].ir.resume) ])
    }
    \p.coord | runerr(500, p)
    if \target then {
        suspend ir_chunk(L[-1].ir.start, [
            ir_MakeList(ir_coord(p.coord), target, args),
            ir_Goto(ir_coord(p.coord), p.ir.success)
            ])
    } else {
        suspend ir_chunk(L[-1].ir.start, [ ir_Goto(ir_coord(p.coord), p.ir.success) ])
    }
    suspend ir_chunk(L[-1].ir.resume, [ ir_Goto(ir_coord(p.coord), L[-2].ir.resume) ])

end

# record a_ListComprehension( expr )
procedure ir_a_ListComprehension(p, st, target, bounded, rval)
    local tmp, v

    \p.coord | runerr(500, p)
    ir_init(p)

    tmp := ir_tmp(st)
    v := ir_tmp(st)

    suspend ir(p.expr, st, tmp, &null, "rval")

    suspend ir_chunk(p.ir.start, [ 
        ir_MakeList(ir_coord(p.coord), v, []),
        ir_Goto(ir_coord(p.coord), p.expr.ir.start)
	])
    /bounded & suspend ir_chunk(p.ir.resume, [ ir_Goto(ir_coord(p.coord), p.ir.failure) ])
    suspend ir_chunk(p.expr.ir.success, [ 
        ir_opfn(ir_coord(p.coord), &null, &null, ir_operator("put", 2, rval), [ v, tmp ], p.ir.failure),
        ir_Goto(ir_coord(p.coord), p.expr.ir.resume)
	])
    suspend ir_chunk(p.expr.ir.failure, [ 
	ir_Move(ir_coord(p.coord), target, v),
        ir_Goto(ir_coord(p.coord), p.ir.success)
	])

end

procedure ir_outer(p)
    case type(p) of {
    "a_ProcDecl" : suspend ir_a_ProcDecl(p)
    "a_Global" : suspend ir_a_Global(p)
    "a_Record" : suspend ir_a_Record(p)
    "a_Invocable" : suspend ir_a_Invocable(p)
    "a_Link" : suspend ir_a_Link(p)
    default : runerr(500, p)
    }
end

procedure ir(p, st, target, bounded, rval)
    case type(p) of {
    "a_NoOp" : suspend ir_a_NoOp(p, st, target, bounded, rval)
    "a_Field" : suspend ir_a_Field(p, st, target, bounded, rval)
    "a_Call" : suspend ir_a_Call(p, st, target, bounded, rval)
    "a_Limitation" : suspend ir_a_Limitation(p, st, target, bounded, rval)
    "a_Not" : suspend ir_a_Not(p, st, target, bounded, rval)
    "a_CoexpList" : suspend ir_a_CoexpList(p, st, target, bounded, rval)
    "a_Alt" : suspend ir_a_Alt(p, st, target, bounded, rval)
    "a_ExcAlt" : suspend ir_a_ExcAlt(p, st, target, bounded, rval)
    "a_RepAlt" : suspend ir_a_RepAlt(p, st, target, bounded, rval)
    "a_Case" : suspend ir_a_Case(p, st, target, bounded, rval)
    "a_Select" : suspend ir_a_Select(p, st, target, bounded, rval)
    "a_Every" : suspend ir_a_Every(p, st, target, bounded, rval)
    "a_Sectionop" : suspend ir_a_Sectionop(p, st, target, bounded, rval)
    "a_Binop" : suspend ir_a_Binop(p, st, target, bounded, rval)
    "a_Unop" : suspend ir_a_Unop(p, st, target, bounded, rval)
    "a_If" : suspend ir_a_If(p, st, target, bounded, rval)
    "a_Initial" : suspend ir_a_Initial(p, st, target, bounded, rval)
    "a_Intlit" : suspend ir_a_Intlit(p, st, target, bounded, rval)
    "a_Reallit" : suspend ir_a_Reallit(p, st, target, bounded, rval)
    "a_Stringlit" : suspend ir_a_Stringlit(p, st, target, bounded, rval)
    "a_Csetlit" : suspend ir_a_Csetlit(p, st, target, bounded, rval)
    "a_ProcDecl" : suspend ir_a_ProcDeclNested(p, st, target, bounded, rval)
    "a_ProcBody" : suspend ir_a_ProcBody(p, st, target, bounded, rval)
    "a_ProcCode" : suspend ir_a_ProcCode(p, st, target, bounded, rval)
    "a_Repeat" : suspend ir_a_Repeat(p, st, target, bounded, rval)
    "a_Return" : suspend ir_a_Return(p, st, target, bounded, rval)
    "a_Fail" : suspend ir_a_Fail(p, st, target, bounded, rval)
    "a_Suspend" : suspend ir_a_Suspend(p, st, target, bounded, rval)
    "a_Until" : suspend ir_a_Until(p, st, target, bounded, rval)
    "a_While" : suspend ir_a_While(p, st, target, bounded, rval)
    "a_Create" : suspend ir_a_Create(p, st, target, bounded, rval)
    "a_Ident" : suspend ir_a_Ident(p, st, target, bounded, rval)
    "a_Next" : suspend ir_a_Next(p, st, target, bounded, rval)
    "a_Break" : suspend ir_a_Break(p, st, target, bounded, rval)
    "a_ToBy" : suspend ir_a_ToBy(p, st, target, bounded, rval)
    "a_Mutual" : suspend ir_a_Mutual(p, st, target, bounded, rval)
    "a_Compound" : suspend ir_a_Compound(p, st, target, bounded, rval)
    "a_ListConstructor" : suspend ir_a_ListConstructor(p, st, target,
                                                   bounded, rval)
    "a_ListComprehension" : suspend ir_a_ListComprehension(p, st, target,
                                                   bounded, rval)
    "a_Key" : suspend ir_a_Key(p, st, target, bounded, rval)
    "a_Arglist" : suspend ir_a_Arglist(p, st, target, bounded, rval)
    "a_Local" : suspend ir_a_Local(p, st, target, bounded, rval)
    "a_Static" : suspend ir_a_Static(p, st, target, bounded, rval)
    default : runerr(500, p)
    }
end

procedure ir_opfn(coord, lhs, lhsclsr, op, args, failLabel)
    static neverfail
    initial {
        neverfail := list(3)
        neverfail[1] := set([ "#", "+", "-", "~", "^", "*", "." ])
        neverfail[2] := set([
            "+", "-", "*", "/", "%", "^", 
            "++", "--", "**", 
            "||", "|||",
            ".", "&"
            # ":=", ":=:" omited because &pos:=*&subject+2 fails
        ])
        neverfail[3] := set([ ])
    }

    op.arity = *args | runerr(500, op)
    if member(neverfail[op.arity],op.name) then {
        failLabel := &null
    }
    return ir_OpFunction(coord, lhs, lhsclsr, op.name, args, op.rval, failLabel)
end

procedure ir_init(p)
    p.ir := ir_info()
    p.ir.start := ir_label(p, "start")
    p.ir.resume := ir_label(p, "resume")
    p.ir.success := ir_label(p, "success")
    p.ir.failure := ir_label(p, "failure")
    return p
end

procedure ir_init_loop(p, st, target, bounded, rval)
    ir_init(p)
    p.ir.x := ir_loopinfo()
    /bounded & (p.ir.x.continue := ir_tmploc(st))
    p.ir.x.nextlabel := ir_label(p, "next")
    p.ir.x.value := target
    p.ir.x.bounded := bounded
    p.ir.x.rval := rval
    return p
end

procedure ir_label(p, suffix)
    return ir_Label(ir_naming(p, suffix))
end

procedure ir_naming(p, suffix)
    local s

    image(p) ? {
        tab(upto(' '))
        move(1)
        s := tab(upto('('))
    }
    return s || "_" || suffix
end

procedure ir_dump(insn)
    return dump_simple(insn, set(["x"]))
end

procedure ir_key(str)
    local k

    static keytable
    initial {
        keytable := table()
    }
    /keytable[str] := str
    return str
end

procedure ir_tmp(st)
    st.tmp +:= 1
    return ir_Tmp("tmp" || st.tmp)
end

procedure ir_tmploc(st)
    st.tmp +:= 1
    return ir_TmpLabel("loc" || st.tmp)
end

procedure ir_tmpclosure(st)
    st.tmp +:= 1
    return ir_TmpClosure("closure" || st.tmp)
end

procedure ir_make_sentinel(L)
    put(L, ir_init(a_NoOp()))
    push(L, ir_init(a_NoOp()))
    return L
end

procedure semantic_error(msg, coord)
    writes(&errout, "File ", (\coord).file, "; Line ", coord.line)
    stop(" # ", msg)
end

procedure ir_coord(p)
	if /p then return &null
	return ir_coordinate(p.file, p.line, p.column)
end

procedure ast2ir(parse, flagList)
    local p, k

    ir_declare_set := set([])
    ir_deferred := []

    while p := @parse do {
        suspend ir_outer(p)
	while k := pop(ir_deferred) do {
		suspend k
	}
    }
end
