#  gen_dot.icn -- create "dot" input from intermediate representation.

global dot_emit_table

procedure dot_emit(label, code)
    dot_emit_table[label] := code
end

procedure n(x)
   return ((\x).name | "_")
end

procedure dot_dump(i)
    case type(i) of {
    default: runerr(500, i)
    "ir_Label" : return i.value
    "ir_MoveLabel" : {
	    return "MoveLabel " ||
	          n(i.lhs) ||
		  " " ||
		  i.label.value
    }
    "ir_Move" : {
	    return "Move " ||
	          n(i.lhs) ||
		  " " ||
		  n(i.rhs)
    }
    "ir_ResumeValue" : {
	    return "ResumeValue " ||
	          n(i.lhs) ||
		  " " ||
		  n(i.lhsclosure) ||
		  " " ||
		  n(i.closure)
    }
    "ir_OpFunction" : {
	    return "Op" ||
	          " " ||
	          n(i.lhs) ||
		  " " ||
		  n(i.lhsclosure) ||
		  " " ||
		  i.fn ||
		  " " ||
		  "[...]"
    }
    "ir_Call" : {
	    return "Call" ||
	          " " ||
	          n(i.lhs) ||
		  " " ||
		  n(i.lhsclosure) ||
		  " " ||
		  n(i.fn) ||
		  " " ||
		  "[...]"
    }
    "ir_MakeClosure" |
    "ir_Key" |
    "ir_Var" : return type(i)[4:0] || " " || n(i.lhs) || " " || i.name
    "ir_StrLit" |  # going to cause problems...
    "ir_CsetLit" |  # going to cause problems...
    "ir_RealLit" |
    "ir_IntLit" : return type(i)[4:0] || " " || n(i.lhs) || " " || i.val
    "ir_Goto" |
    "ir_IndirectGoto" |
    "ir_Fail" |
    "ir_EnterScope" |
    "ir_ExitScope" : return type(i)[4:0]
    }
end

procedure dot_output(t)
    local label, code, lab, s, i, insn

    every label := key(t) & code := t[label] do {
        lab := label.value

        writes(lab)
        writes(" [shape=record,label=")
        s := "{ <f0> "
        s ||:= dot_dump(label) || ":"
        every i := 1 to *code do {
            s ||:= " |"
            s ||:= "<f" || i || "> " || dot_dump(code[i])
        }
        s ||:= " }"
        writes(image(s))
        write("];")

        every i := 1 to *code do {
            insn := code[i]
            case type(insn) of {
            "ir_IndirectGoto" : {
                every write(lab, ":f", i, " ->", image(dot_dump(!insn.labelList)))
                }
            "ir_Goto" : {
                write(lab, ":f", i, " ->", image(dot_dump(insn.targetLabel)))
                }
            "ir_Call" |
            "ir_OpFunction" |
            "ir_ResumeValue" : {
                write(lab, ":f", i,
                      " ->",
                      image(dot_dump(\insn.failLabel)), " [label=failure]")
                }
            "ir_Succeed" : {
                write(lab, ":f", i,
                      " ->",
                      image(dot_dump(\insn.resumeLabel)),
                      " [label=resumeLabel]")
                }
            "ir_CoRet" : {
                write(lab, ":f", i,
                      " ->",
                      image(dot_dump(insn.resumeLabel)),
                      " [label=resumeLabel]")
                }
            }
        }
    }
end

procedure dot_function(name, params, accumulate, locals, statics, code,
                       codestart, coord)
    local i

    write("digraph ", name, " {")
    write("ratio=auto;")
    # write("page=\"8.5,11\";")	# breaks output into letter-sized pages
    dot_emit_table := table()
    every i := !code do {
        dot_emit_table[i.label] := i.insnList
    }
    dot_output(dot_emit_table)
    write("}")
end

procedure dot_File(irgen, flagList)
    local p
    while p := @irgen do {
        case type(p) of {
        "ir_Global" : { }
        "ir_Record" : { }
        "ir_Invocable" : { }
        "ir_Link" : { }
        "ir_Function" : {
            dot_function(p.name, p.paramList, p.accumulate, p.localList,
                         p.staticList, p.codeList, p.codeStart)
        }
        default: runerr(500, p)
        }
    }
end
